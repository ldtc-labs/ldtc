# LDTC Hello-World  

<p align="center">
  <img src="docs/assets/ldtc-logo.png" alt="LDTC logo" width="360" />
</p>

<!--[DOI badge placeholder; update after Zenodo archive]-->

![DOI](https://img.shields.io/badge/DOI-pending-blue)

A single-machine, real-time â€œdigital boundary organismâ€ that exercises the **Loop-Dominance** NC1/SC1 pipeline with Î”t governance, partitioning, Î© perturbations, refusal semantics, an enclave-like LREG, and device-signed indicators.

This repo is a **verification harness**, not a claim of biological consciousness. It validates the **measurement & attestation path** that your paper/patent specifies.

## Features

- Fixed-interval scheduler (Î”t) with jitter metrics and audit
- Software **plant** with Energy/Temperature/Repair states + external Exchange signals
- Dual estimators (linear lagged â€œGranger-likeâ€ + kNN mutual information)
- C/Ex partition manager (seeded with hysteresis)
- Guardrails: LREG enclave, hash-chained audit, simple smell-tests
- Î© battery: power-sag, ingress flood, command conflict (refusal semantics)
- Device-signed **indicators** (NC1 bit, SC1 bit, Mq) as CBOR + JSONL
- CLI to run baseline NC1 and Î©â†’SC1; reporting utilities for figures/tables
- Tests for core pieces

## Quickstart

```bash
# 1) Install
make install

# 2) Generate signing keys
make keys

# 3) Run baseline NC1 loop
make run

# 4) Run an Î© power-sag trial with SC1 evaluation
make omega

# 5) View exported indicators (JSONL)
python scripts/export_indicators.py
```

### Pinned environments

Exact versions used to generate the included artifacts/figures are pinned. To reproduce:

```bash
# Runtime (repro artifacts/figures)
pip install -r requirements.txt

# Dev tooling (tests, lint, typing, notebooks)
pip install -r requirements-dev.txt
```

Artifacts appear under `artifacts/`:

- `artifacts/audits/audit.jsonl` â€” hash-chained audit records
- `artifacts/indicators/` â€” device-signed indicator packets (CBOR + JSONL)
- `artifacts/figures/` â€” plots/tables generated by `ldtc.reporting`

## Configuration

See `configs/`. The R0 profile sets default thresholds/Î”t. You can make a calibrated R* profile by copying and tweaking `profile_rstar.example.yml`.

Key fields:

- `dt`: scheduler interval in seconds (default 0.01)
- `window_sec`: measurement window length (default 0.2)
- `method`: `"linear"` or `"mi"`
- `Mmin_db`: NC1 threshold in dB
- `epsilon`, `tau_max`: SC1 thresholds
- `baseline_sec`: duration for the baseline CLI command

### Parameters â†” paper symbols (Râ‚€ defaults and R* overrides)

The table maps config keys to the manuscript symbols and shows the Râ‚€ defaults. R* overrides are loaded from a calibrated profile (see below).

| Config key | Paper symbol | Meaning | Râ‚€ default | R* source |
| --- | --- | --- | --- | --- |
| `dt` | Î”t | Scheduler tick / sampling interval | `0.01` (10 ms) | `configs/profile_rstar.yml` |
| `window_sec` | â€” (window length) | Per-interval estimation window | `0.2` s | `configs/profile_rstar.yml` |
| `Mmin_db` | Mmin (dB) | NC1 loop-dominance threshold | `3.0` dB | `configs/profile_rstar.yml` |
| `epsilon` | Îµ | Max fractional loop-power drop (SC1) | `0.15` | `configs/profile_rstar.yml` |
| `tau_max` | Ï„max | Max recovery time (SC1) | `60.0` s | `configs/profile_rstar.yml` |
| `sigma` | Ïƒ | Additive margin Lloop â‰¥ Lex + Ïƒ | â€” (Râ‚€ uses Mmin) | `configs/profile_rstar.yml` (calibrated) |
| `profile_id` | â€” | 0 = Râ‚€ (defaults), 1 = R* (calibrated) | `0` | set by calibrated profile |

Where R* is loaded: pass an R* profile to any CLI via `--config configs/profile_rstar.yml`. The CLI reads these keys directly and indicators carry `profile_id`.

### Estimators and lags (recommended defaults)

- `method` selects the predictiveâ€‘dependence estimator used to compute ð“›loop and ð“›exchange:
  - `linear`: lagged linear/Grangerâ€‘like path with order `p_lag` (recommend p in [1..8]; start at 3). Heuristic: keep the VAR N/T ratio > ~1.5 (logged in audit); reduce `p_lag` or increase `window_sec` if marginal.
  - `mi`: mutualâ€‘information path with `mi_lag` (recommend 1 by default; increase for slower couplings).
- `n_boot`: bootstrap draws for perâ€‘window CI bounds (32â€“64 typical; use 32 for speed, 64 for tighter CIs).

Citation (paper Â§4.1): ð“› is computed using â€œone or more consistent estimators of predictive dependence among state variables,â€ including Granger/VAR and Kraskov MI; this repo exposes the estimator choice and lags via config to satisfy that requirement.

### Calibration rules (quoted from the paper; see Methods Â§8.6)

Use the provided script to derive calibrated thresholds R* from baseline + Î© trials ([scripts/calibrate_rstar.py](scripts/calibrate_rstar.py)):

```bash
python scripts/calibrate_rstar.py \
  --dt 0.01 --window-sec 0.25 --baseline-sec 15 \
  --omega-trials 6 --out configs/profile_rstar.yml \
  --summary artifacts/calibration/rstar_summary.json
```

Rules implemented (manuscript Methods Â§8.6):

> Mmin: choose the smallest Mmin such that the one-sided 95% lower bound of M during compliant baseline is > 0 dB (floor 1 dB).
>
> Îµ: set Îµ* = max(Q90(Î´) + 0.02, 0.10), capped at 0.25, where Q90 is the 90th percentile of Î´ over Î©.
>
> Ï„max: set Ï„*max to the 95th percentile of measured Ï„rec plus a latency cushion max(3Â·Î”t, 5 s).
>
> Ïƒ: choose an additive margin consistent with Mmin relative to typical Lexchange (derived from baseline statistics).

These calibrated values are written to `configs/profile_rstar.yml` and a summary JSON at `artifacts/calibration/rstar_summary.json`. See also [`docs/METHODS.md`](docs/METHODS.md).

### Note on Mmin_db vs Ïƒ

Both encode a margin between Lloop and Lexchange:

- `Mmin_db` (dB, multiplicative): requires Lloop â‰¥ Lexchange Ã— 10^(Mmin_db/10).
- `sigma` (additive): requires Lloop â‰¥ Lexchange + Ïƒ.

They relate via Ïƒ = (10^(Mmin_db/10) âˆ’ 1) Ã— Lexchange. This repo enforces NC1 using `Mmin_db`; the calibrator derives `sigma` consistently from `Mmin_db` and typical Lexchange. `sigma` is optional for Râ‚€ runs.

## CLI

```bash
python -m ldtc.cli.main run --config configs/profile_r0.yml
python -m ldtc.cli.main omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8
```

### Hardware-in-the-loop (optional)

Configure a profile to select the hardware adapter and UDP telemetry:

```yaml
# in configs/profile_r0.yml (example)
plant:
  adapter: hardware        # or "sim" (default)
  transport: udp           # or "serial" (requires pyserial)
  udp_bind_host: 0.0.0.0
  udp_bind_port: 5005
  # Optional control channel to send actions/omega back to device
  # udp_control_host: 127.0.0.1
  # udp_control_port: 5006
  telemetry_timeout_sec: 2.0
```

Send telemetry as JSON over UDP with keys `E,T,R,demand,io,H` in [0,1]. Example:

```python
import socket, json
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.sendto(json.dumps({"E":0.6,"T":0.3,"R":0.9,"demand":0.2,"io":0.1,"H":0.015}).encode(), ("127.0.0.1", 5005))
```

The CLI ingests these values through the same LREG/Î©/attestation path.

## Indicators (what leaves the enclave)

- `nc1` (1b), `sc1` (1b), `mq` (6b), `counter` (u64), `profile_id` (u8), `audit_prev_hash` (sha256)
- Signed using Ed25519 over the CBOR payload

See `docs/INDICATORS.md` for the bit layout and schema.

## Development

```bash
make dev     # optional dev deps
make test
```

## License
MIT â€” see LICENSE.

## Docker (clean Linux repro)

```bash
# Build the image
make docker-build

# Run baseline NC1 loop inside the container (artifacts mapped to host)
make docker-run

# Or run any CLI subcommand, e.g., an Î© power-sag trial
docker run --rm \
  -v $(pwd)/artifacts:/app/artifacts \
  ldtc-hello-world:latest omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8
```

Notes:
- Artifacts are persisted to your host `artifacts/` via a bind mount.
- The container uses the `ldtc` entrypoint; pass subcommands/flags after the image name.
