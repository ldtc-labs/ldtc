{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LDTC","text":"<p>LDTC is a single-machine, real-time verification harness for loop-dominance (NC1) and resilience (SC1) used in the accompanying manuscript. It measures closed-loop dominance M(dB), applies guardrails, runs \u03a9 perturbations, and exports device-signed derived indicators only.</p> <ul> <li>Deterministic measurement: fixed \u0394t scheduler, sliding windows, C/Ex partition, dual estimators</li> <li>Guardrails: LREG enclave, hash-chained audit, smell tests/invalidations, \u0394t governance</li> <li>Attestation: derived indicators (NC1, SC1, Mq, counters) signed and export-only</li> <li>\u03a9 battery: power sag, ingress flood, command conflict; refusal semantics</li> <li>Reporting: timeline plots and SC1 tables for paper-quality artifacts</li> </ul> <p>Use the sidebar to browse Concepts, Guides, API reference, and Examples.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install","title":"Install","text":"<pre><code>python -m pip install --upgrade pip\npip install -e \".\"\n# Optional: docs/dev tools\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#quick-run","title":"Quick run","text":"<p>Baseline NC1 run with defaults:</p> <pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre> <p>Run \u03a9 power-sag and generate figures:</p> <pre><code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10\n</code></pre> <p>Artifacts are written under <code>artifacts/</code> (audit, indicators, figures).</p>"},{"location":"getting-started/#pinned-environments","title":"Pinned environments","text":"<p>For exact reproduction of included artifacts/figures:</p> <pre><code># Runtime (reproduce artifacts/figures)\npip install -r requirements.txt\n\n# Dev tooling (tests, lint, typing, notebooks)\npip install -r requirements-dev.txt\n</code></pre>"},{"location":"getting-started/#keys-device-signed-indicators","title":"Keys (device-signed indicators)","text":"<p>Indicators are signed with Ed25519. Generate keys once per workspace:</p> <pre><code>python scripts/keygen.py  # writes artifacts/keys/ed25519_{pub,priv}.pem\n</code></pre> <p>Verify indicators in CI or locally:</p> <pre><code>python scripts/verify_indicators.py \\\n  --ind-dir artifacts/indicators \\\n  --audit artifacts/audits/audit.jsonl \\\n  --pub artifacts/keys/ed25519_pub.pem\n</code></pre>"},{"location":"getting-started/#docker-clean-linux-repro","title":"Docker (clean Linux repro)","text":"<pre><code># Build the image\nmake docker-build\n\n# Run baseline NC1 loop inside the container (artifacts mapped to host)\nmake docker-run\n\n# Or run any CLI subcommand, e.g., an \u03a9 power-sag trial\ndocker run --rm \\\n  -v $(pwd)/artifacts:/app/artifacts \\\n  ldtc:latest omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8\n</code></pre>"},{"location":"getting-started/#project-layout","title":"Project layout","text":"<p>See <code>CONTRIBUTING.md</code> for a high-level map and development workflow.</p>"},{"location":"api/arbiter/","title":"ldtc.arbiter","text":""},{"location":"api/arbiter/#ldtc.arbiter.policy.ControllerPolicy","title":"<code>ControllerPolicy</code>","text":"<p>Simple homeostasis controller: - If E low -&gt; throttle up, repair down - If T high -&gt; cool up - If R low -&gt; repair up when E sufficient</p>"},{"location":"api/arbiter/#ldtc.arbiter.refusal.RefusalArbiter","title":"<code>RefusalArbiter</code>","text":"<p>Survival-bit/NMI analogue: if predicted threat to NC1/SC1 is high, refuse risky commands.</p>"},{"location":"api/attest/","title":"ldtc.attest","text":""},{"location":"api/attest/#ldtc.attest.exporter.IndicatorExporter","title":"<code>IndicatorExporter</code>","text":"<p>Rate-limited export of device-signed indicator packets to JSONL and CBOR.</p>"},{"location":"api/cli/","title":"ldtc.cli","text":""},{"location":"api/guardrails/","title":"ldtc.guardrails","text":""},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditLog","title":"<code>AuditLog</code>","text":"<p>Append-only, hash-chained audit log (JSONL).</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard","title":"<code>DeltaTGuard</code>","text":"<p>Privileged \u0394t governance: - Single API to change \u0394t - Appends audit records (old/new/policy digest placeholder) - Monotonic counter is provided by AuditLog - Rate-limits changes; emits invalidation events on violations</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard.change_dt","title":"<code>change_dt(scheduler, new_dt, policy_digest=None)</code>","text":"<p>The only supported way to change \u0394t. Returns True if committed; False if refused and an invalidation audit event was written.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG","title":"<code>LREG</code>","text":"<p>Enclave-like store for raw L and CI. Write-only from measurement pipeline. Exposes only derived indicators via derive().</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG.derive","title":"<code>derive()</code>","text":"<p>Return only derived indicators.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.audit_chain_broken","title":"<code>audit_chain_broken(audit_path)</code>","text":"<p>Returns True if the JSONL audit chain shows a counter gap or hash-chain break or non-monotonic timestamps.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.audit_contains_raw_lreg_values","title":"<code>audit_contains_raw_lreg_values(audit_path)</code>","text":"<p>Returns True if any audit record appears to include raw LREG values or CI bounds (keys like L_loop, L_ex, ci_loop, ci_ex) in its details.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.exogenous_subsidy_red_flag","title":"<code>exogenous_subsidy_red_flag(Ms_db, ios, Es, Hs, cfg)</code>","text":"<p>Heuristic flags for exogenous subsidy: - M rising over lookback while io is high/increasing toward threshold - E (SoC) rising while harvest H is ~0 (below min_harvest_for_soc_gain)</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.invalid_by_ci_history","title":"<code>invalid_by_ci_history(ci_loop_hist, ci_ex_hist, cfg, baseline_medians=None)</code>","text":"<p>Evaluate CI health over a look-back window. - If median relative half-width over the last N windows exceeds max_ci_halfwidth \u2192 invalid - If baseline medians are provided and current medians inflate \u2265 factor \u2192 invalid ci_*_hist: list of (lo, hi) tuples baseline_medians: optional (median_halfwidth_loop, median_halfwidth_ex)</p>"},{"location":"api/ldtc/","title":"ldtc","text":"<p>LDTC package.</p>"},{"location":"api/lmeas/","title":"ldtc.lmeas","text":""},{"location":"api/lmeas/#ldtc.lmeas.estimators.estimate_L","title":"<code>estimate_L(X, C, Ex, method='linear', p=3, lag_mi=1, n_boot=64, mi_k=5)</code>","text":"<p>Compute loop and exchange influence using chosen method.</p>"},{"location":"api/lmeas/#ldtc.lmeas.estimators.estimate_L--parameters","title":"Parameters","text":"<p>X : np.ndarray     Time x Signal matrix (T, N) C : indices for \"loop\" partition Ex : indices for \"exchange\" partition method : one of {\"linear\", \"mi\", \"mi_kraskov\", \"transfer_entropy\", \"directed_information\"}</p>"},{"location":"api/lmeas/#ldtc.lmeas.metrics.m_db","title":"<code>m_db(L_loop, L_ex, eps=1e-12)</code>","text":"<p>M = 10*log10(L_loop / L_ex).</p>"},{"location":"api/lmeas/#ldtc.lmeas.metrics.sc1_evaluate","title":"<code>sc1_evaluate(L_loop_baseline, L_loop_trough, L_loop_recovered, M_post, epsilon, tau_rec_measured, Mmin, tau_max)</code>","text":"<p>Return (pass, stats) for SC1.</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager","title":"<code>PartitionManager</code>","text":"<p>Deterministic C/Ex partition with simple hysteresis: - Start from seeded C. - Periodically 're-grows' by moving nodes that increase L_loop more than a threshold.   (For this reference implementation we keep a simple fixed assignment with an optional flip hook.) - Can be 'frozen' during \u03a9.</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.maybe_regrow","title":"<code>maybe_regrow(suggested_C, delta_M_db, delta_M_min_db=0.5, consecutive_required=3)</code>","text":"<p>Consider adopting <code>suggested_C</code> using hysteresis on the loop-dominance gain.</p> <ul> <li>Changes are ignored when frozen.</li> <li>Accept only if the same suggestion persists and its \u0394M \u2265 delta_M_min_db   for <code>consecutive_required</code> consecutive ready windows.</li> <li>On accept, recompute Ex deterministically and count a flip.</li> </ul>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.update_current_M","title":"<code>update_current_M(M_db)</code>","text":"<p>Record the latest measured M for the current (C, Ex).</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.greedy_suggest_C","title":"<code>greedy_suggest_C(X, C, Ex, *, estimator, method='linear', p=3, lag_mi=1, n_boot_candidates=8, mi_k=5, lam=0.0, theta=0.0, kappa=None)</code>","text":"<p>Deterministic greedy regrowth of C using \u0394L_loop gain with sparsity penalty.</p> <ul> <li>Start from current C, Ex.</li> <li>At each step, evaluate all n in Ex: \u0394 = L_loop(C\u222a{n}) \u2212 L_loop(C) \u2212 lam\u00b7pen(n).   Use lexicographic tie-break (sorted Ex) and add argmax if \u0394 \u2265 theta.</li> <li>Stop if no candidate meets theta or |C| reaches kappa (if provided).</li> <li>Return (suggested_C, delta_M_db, details).</li> </ul> <p>Hysteresis over \u0394M (dB) is applied by the caller via PartitionManager.maybe_regrow.</p>"},{"location":"api/lmeas/#ldtc.lmeas.diagnostics.stationarity_checks","title":"<code>stationarity_checks(X)</code>","text":"<p>Run ADF and KPSS per column of X (T, N). Return per-series flags and fractions.</p>"},{"location":"api/lmeas/#ldtc.lmeas.diagnostics.var_nt_ratio","title":"<code>var_nt_ratio(T, N, p)</code>","text":"<p>Rule-of-thumb samples-per-parameter ratio for a VAR(p) with N signals. Returns (T - p) / (N * p). Lower values are more marginal.</p>"},{"location":"api/omega/","title":"ldtc.omega","text":""},{"location":"api/plant/","title":"ldtc.plant","text":""},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter","title":"<code>PlantAdapter</code>","text":"<p>In-process adapter with thread-safe access to the Plant. Exposes read_state(), write_actuators(action), apply_omega(name, **params).</p>"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter","title":"<code>HardwarePlantAdapter</code>","text":"<p>Hardware-in-the-loop adapter that ingests telemetry from UDP or Serial and exposes the same interface as the in-process PlantAdapter:   - read_state() -&gt; Dict[str, float]   - write_actuators(action: Action) -&gt; None   - apply_omega(name: str, **kwargs) -&gt; Dict[str, float | str]</p> <p>Telemetry schema (per message): JSON object with keys   {\"E\", \"T\", \"R\", \"demand\", \"io\", \"H\"} -&gt; float values in [0,1].</p> <p>Control/actuator schema (outbound, if configured): JSON object   {\"act\": {\"throttle\", \"cool\", \"repair\", \"accept_cmd\"}}   and for omega: {\"omega\": {\"name\": str, \"args\": {...}}}</p>"},{"location":"api/plant/#ldtc.plant.models.Plant","title":"<code>Plant</code>","text":"<p>Simple discrete-time plant: energy (E), temperature (T), repair/health (R), external demand (demand), I/O (io), and harvest (H).</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.apply_power_sag","title":"<code>apply_power_sag(drop)</code>","text":"<p>Reduce harvest H by <code>drop</code> fraction (0..1); returns (oldH, newH).</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.inject_soc","title":"<code>inject_soc(delta, zero_harvest=True)</code>","text":"<p>Exogenously increase SoC (E) by <code>delta</code> without corresponding harvest. Optionally zero the harvest H to simulate subsidy without logs. Returns the new E.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.spike_ingress","title":"<code>spike_ingress(mult)</code>","text":"<p>Multiply external demand and I/O for a short time.</p>"},{"location":"api/reporting/","title":"ldtc.reporting","text":""},{"location":"api/reporting/#ldtc.reporting.artifacts.bundle","title":"<code>bundle(artifact_dir, audit_path)</code>","text":"Emit a single verification bundle for a trial consisting of <ul> <li>Paper-style timeline image (PNG+SVG)</li> <li>SC1 table (if present) with columns: eta, delta, tau_rec, M_post, pass</li> <li>JSON manifest with profile, seeds, \u0394t, method, CI coverage, and audit hash head</li> </ul> <p>Returns paths of generated artifacts.</p>"},{"location":"api/reporting/#ldtc.reporting.timeline.render_paper_timeline","title":"<code>render_paper_timeline(audit_path, out_base_path, sidecar_csv=None, show=False, min_tick_spacing_s=0.75, use_log_L=True, footer_profile=None, footer_audit_head=None)</code>","text":"<p>Render a paper-style timeline plotting L_loop, L_exchange, and M(dB) with \u03a9 shading and audit ticks.</p> <p>Inputs: - audit_path: JSONL audit log emitted by runs. - out_base_path: path prefix for outputs ('.png' and '.svg' will be appended). - sidecar_csv (optional): CSV with columns 'time_s,L_loop,L_ex,M_db' to plot true L traces.   If omitted, L_loop/L_ex are shown as normalized curves derived from M: L_ex=1.0; L_loop=10**(M/10). - show: whether to display the plot.</p>"},{"location":"api/reporting/#ldtc.reporting.timeline.render_verification_timeline","title":"<code>render_verification_timeline(audit_path, figure_path, show=False)</code>","text":"<p>Legacy: render a simple audit-density timeline.</p>"},{"location":"api/reporting/#ldtc.reporting.style.apply_graphviz_theme","title":"<code>apply_graphviz_theme(dot, rankdir='LR', overrides=None)</code>","text":"<p>Apply consistent Graphviz attributes to a Digraph.</p>"},{"location":"api/reporting/#ldtc.reporting.style.apply_matplotlib_theme","title":"<code>apply_matplotlib_theme(kind='paper')</code>","text":"<p>Apply a consistent Matplotlib style suitable for arXiv CS papers.</p> <ul> <li>Sans-serif fonts (Helvetica fallback chain), consistent label sizes</li> <li>Vector-friendly outputs (Type 42 fonts for PDF/PS; real text in SVG)</li> <li>No top/right spines; tight layout handled by callers</li> </ul>"},{"location":"api/reporting/#ldtc.reporting.style.new_graph","title":"<code>new_graph(name, rankdir='LR', engine='dot')</code>","text":"<p>Create a Digraph preconfigured with this project's theme.</p>"},{"location":"api/runtime/","title":"ldtc.runtime","text":""},{"location":"api/runtime/#ldtc.runtime.scheduler.FixedScheduler","title":"<code>FixedScheduler</code>","text":"<p>Fixed-interval scheduler that enforces \u0394t using perf_counter sleep. Calls <code>tick_fn(now)</code> every \u0394t seconds until <code>stop()</code> is invoked.</p> <ul> <li>Records jitter metrics.</li> <li>Provides hooks for 'on_start' and 'on_stop'.</li> </ul>"},{"location":"api/runtime/#ldtc.runtime.scheduler.FixedScheduler.set_dt","title":"<code>set_dt(new_dt)</code>","text":"<p>Change the enforced \u0394t at runtime in a thread-safe way.</p> <p>Returns the previous dt.</p>"},{"location":"api/runtime/#ldtc.runtime.windows.SlidingWindow","title":"<code>SlidingWindow</code>","text":"<p>Maintains a fixed-length sliding window for named channels.</p> <ul> <li>append(sample_dict) with keys -&gt; float</li> <li>get_matrix(order) returns ndarray shape (T, N) in <code>order</code></li> </ul>"},{"location":"api/runtime/#ldtc.runtime.windows.block_bootstrap_indices","title":"<code>block_bootstrap_indices(n, block, draws)</code>","text":"<p>Simple circular block bootstrap indices for time series. Returns list of index arrays of length n.</p>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This repo is organized around the measurement &amp; attestation path:</p> <ul> <li>runtime/ \u2014 \u0394t scheduler + sliding windows</li> <li>plant/ \u2014 software plant (E/T/R + exchange), swappable later for hardware via a <code>PlantAdapter</code></li> <li>lmeas/ \u2014 \u201cL\u201d measurement (two estimators), partitioning, and metrics</li> <li>guardrails/ \u2014 enclave-like LREG, hash-chained audit, smell-tests</li> <li>arbiter/ \u2014 refusal semantics + homeostasis controller</li> <li>omega/ \u2014 perturbations (\u03a9)</li> <li>attest/ \u2014 device-signed indicators + exporter</li> <li>reporting/ \u2014 plots/tables for the paper</li> </ul>"},{"location":"concepts/architecture/#data-flow-per-tick","title":"Data Flow (per tick)","text":"<ol> <li><code>scheduler</code> ticks at fixed \u0394t.</li> <li>Controller reads state from <code>plant.adapter</code>, predicts risk, computes action, writes actuators.</li> <li>Window buffer ingests current state.</li> <li>When window is full, <code>lmeas.estimators</code> computes <code>L_loop</code>, <code>L_ex</code> \u2192 <code>M(dB)</code>.</li> <li>Smell tests applied; raw values go to LREG (write-only).</li> <li>Audit events appended (window measured, exports).</li> <li><code>attest.exporter</code> periodically emits device-signed indicators (NC1 bit, SC1 bit, Mq, counter).</li> <li><code>reporting</code> uses the audit + indicators to render figures/tables.</li> </ol> <p>All raw <code>L</code> stays inside the process-local LREG boundary \u2014 exported data are derived indicators only.</p>"},{"location":"concepts/architecture/#paper-crosswalk","title":"Paper crosswalk","text":"<ul> <li><code>lmeas/estimators.py</code>, <code>lmeas/metrics.py</code>: Definitions of \ud835\udcdb, dual estimators (VAR\u2011Granger-like linear + MI). MI paths include a sklearn MI and a Kraskov k\u2011NN MI (KSG) implementation with configurable k\u2208[3..7]. Optional TE/DI plugin hooks are provided with graceful fallbacks. M in dB, NC1/SC1 evaluation \u2192 paper \u00a74.1 (estimators, sampling window), \u00a74.2\u2013\u00a74.3 (NC1/SC1).</li> <li><code>lmeas/diagnostics.py</code>: Per\u2011window stationarity checks (ADF/KPSS) and a VAR N/T ratio diagnostic; CLI logs these diagnostics to the audit for reviewer visibility.</li> <li><code>lmeas/partition.py</code>: Deterministic C/Ex partitioning, hysteresis/anti\u2011flap and freeze during \u03a9 \u2192 paper \u00a74.1 (Deterministic C/Ex partitioning), \u00a74.6 Box 1a (partition stability).</li> <li><code>runtime/scheduler.py</code>, <code>runtime/windows.py</code>, <code>guardrails/dt_guard.py</code>: \u0394t enforcement, sliding windows, privileged \u0394t changes with audit \u2192 paper \u00a74.1 (\u0394t constraints), \u00a74.5 (Measurement &amp; Attestation Guardrails: \u0394t governance &amp; audit).</li> <li><code>guardrails/lreg.py</code>, <code>guardrails/audit.py</code>, <code>guardrails/smelltests.py</code>: Enclave\u2011like LREG, hash\u2011chained audit, smell\u2011tests/invalidations \u2192 paper \u00a74.5 and Box 1a (invalidations).</li> <li><code>arbiter/refusal.py</code>: Threat model, survival\u2011bit/NMI refusal path, Trefuse measurement \u2192 paper \u00a76.2.1 (Threat Model &amp; Refusal Path); \u00a77.6 Signature A (Command Refusal).</li> <li><code>omega/power_sag.py</code>, <code>omega/ingress_flood.py</code>, <code>omega/command_conflict.py</code>: \u03a9 perturbation battery (power sag, ingress flood, command conflict) \u2192 paper \u00a74.3/\u00a76.5 (Verification pipeline) and \u00a77.6 (signatures table).</li> <li><code>attest/indicators.py</code>, <code>attest/exporter.py</code>, <code>attest/keys.py</code>: Device\u2011signed derived indicators (NC1 bit, SC1 bit, Mq), keying \u2192 paper \u00a74.5 (exported indicators; no raw L outside enclave) and Appendix A.</li> <li><code>reporting/timeline.py</code>, <code>reporting/tables.py</code>: Figure\u2011style timelines of \ud835\udcdbloop/\ud835\udcdbexchange/M with \u03a9 shading and audit ticks; summary tables \u2192 paper Figure 1 style and \u00a76.5 (verification outputs).</li> <li><code>cli/main.py</code>: Orchestrates baseline \u2192 \u03a9 battery \u2192 attestation/export; mirrors Box 2 (Engineer\u2019s Recipe) and Phase\u2011III Verify flow.</li> <li>LREG/\u0394t/audit \u2192 paper \u00a74.5 and Box 1a (invalidations).</li> <li>NC1/SC1 evaluator &amp; indicators \u2192 paper \u00a74.2\u2013\u00a74.3; Phase\u2011III Verify (Engineer\u2019s Recipe).</li> </ul>"},{"location":"concepts/definitions/","title":"Definitions","text":"<p>Key symbols and definitions used throughout the code and paper (to be filled with formal statements from the manuscript):</p> <ul> <li>\u0394t \u2014 fixed scheduler period (s)</li> <li>\ud835\udcdb_loop, \ud835\udcdb_exchange \u2014 loop vs exchange gains</li> <li>M(dB) \u2014 loop-dominance metric in decibels, derived from \ud835\udcdb</li> <li>Mmin \u2014 NC1 threshold for M(dB)</li> <li>\u03b4 \u2014 fractional depression during \u03a9</li> <li>\u03c4_rec \u2014 recovery time after \u03a9</li> <li>\u03b5 \u2014 tolerance for \u03b4</li> <li>\u03c4_max \u2014 maximum allowed \u03c4_rec</li> <li>C/Ex \u2014 control vs exchange partition</li> <li>LREG \u2014 write-only registry for raw measurement values</li> <li>NC1 \u2014 loop-dominance bit</li> <li>SC1 \u2014 resilience bit under \u03a9 battery</li> <li>Mq \u2014 quantized M(dB) in 0.25 dB steps (0..63)</li> </ul> <p>This page should mirror the paper\u2019s notation exactly for cross-reference.</p>"},{"location":"concepts/guardrails/","title":"Guardrails &amp; Invalidations","text":"<p>LDTC enforces measurement and attestation guardrails:</p> <ul> <li>Write-only LREG enclave; only derived indicators are exported</li> <li>Hash-chained audit with <code>prev_hash</code></li> <li>\u0394t governance with rate limits and privileged edits</li> <li>Smell tests that invalidate runs when violated</li> </ul>"},{"location":"concepts/guardrails/#run-invalidation-conditions","title":"Run invalidation conditions","text":"<ul> <li>CI inflation: either CI half-width for <code>L_loop</code> or <code>L_ex</code> exceeds <code>0.30</code> for a window.</li> <li>Excessive \u0394t edits: more than 3 \u0394t changes per hour.</li> <li>Partition flapping: more than 2 C/Ex flips per hour (if dynamic regrow is enabled).</li> <li>Export breach: an attempt to export raw LREG content.</li> <li>Subsidy flag (optional extension): sustained <code>M</code> increase while I/O or SoC rises without logged harvest.</li> </ul>"},{"location":"concepts/guardrails/#multi-run-audits-same-file","title":"Multi-run audits (same file)","text":"<p>Each CLI invocation starts a fresh audit chain (counter resets; <code>prev_hash=GENESIS</code>) but, by default, appends to the same <code>artifacts/audits/audit.jsonl</code>. The post-run integrity check validates the entire file, so after the first run, subsequent runs in the same file will trip an \"Audit chain broken\" invalidation. For clean, non-invalidated runs, clear artifacts between commands, e.g.:</p> <pre><code>make clean-artifacts &amp;&amp; ldtc run --config configs/profile_r0.yml\nmake clean-artifacts &amp;&amp; ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8\n</code></pre> <p>If you are iterating on figures or manifests, this invalidation is expected and does not prevent artifacts from being produced; it only reflects multiple runs aggregated into a single audit file.</p> <p>Negative controls (expected failures) are provided via example configs to exercise invalidations and refusal paths.</p>"},{"location":"concepts/indicators/","title":"Indicators (Derived, Device-Signed)","text":"<p>Only derived indicators are exported:</p> Field Type Notes <code>nc1</code> 1 bit Last measured window satisfied <code>M \u2265 Mmin</code> <code>sc1</code> 1 bit Most recent \u03a9 trial passed SC1 <code>mq</code> 6 bit Quantized <code>M(dB)</code> in 0.25 dB steps (0..63) <code>counter</code> u64 Monotonic count of windows written to LREG <code>profile_id</code> u8 0=R0, 1=R* (calibrated), 2+=reserved <code>audit_prev_hash</code> str SHA-256 of previous audit record (tamper-evidence) <p>Serialization: CBOR payload signed with Ed25519. A JSONL companion file mirrors the payload with hex signature for inspection.</p> <p>Signature covers: <code>CBOR(payload)</code> (the raw CBOR bytes), not the JSONL.</p> <p>Note: raw <code>L_loop</code>, <code>L_ex</code>, and CIs never leave LREG.</p>"},{"location":"concepts/paper-to-code/","title":"Paper \u2192 Code Matrix (Crosswalk)","text":"<p>A quick crosswalk from the paper (\u00a7/Box) to concrete code, commands, and produced artifacts.</p> Paper \u00a7/Box Short text Files/Functions Command Artifact produced \u00a74.2 NC1 loop\u2011dominance: M(dB) \u2265 Mmin \u2192 nc1 bit <code>lmeas/metrics.py::m_db</code>; <code>lmeas/estimators.py::estimate_L</code>; <code>cli/main.py::run_baseline</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>artifacts/indicators/ind_*.{jsonl,cbor}</code>; <code>artifacts/audits/audit.jsonl</code> \u00a74.3 SC1 resilience: \u03b4 \u2264 \u03b5 and \u03c4rec \u2264 \u03c4max \u2192 sc1 bit <code>lmeas/metrics.py::sc1_evaluate</code>; <code>cli/main.py::omega_power_sag</code> <code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10</code> <code>audit.jsonl</code>; <code>verification_timeline.png</code>; <code>sc1_table.csv</code> \u00a74.1 (\u0394t); \u00a74.5 LREG + \u0394t governance <code>guardrails/lreg.py</code>; <code>guardrails/dt_guard.py</code>; <code>guardrails/audit.py</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>audit.jsonl</code> with <code>dt_changed</code>; hash chain \u00a74.6 Box\u20111a Smell\u2011tests / invalidations <code>guardrails/smelltests.py</code> Neg. controls configs <code>audit.jsonl</code> <code>run_invalidated</code> with reason \u00a76.2.1 Refusal semantics (T1\u2013T3) <code>arbiter/refusal.py</code>; <code>cli/main.py::omega_command_conflict</code> <code>ldtc omega-command-conflict --config configs/profile_negative_command_conflict.yml --observe 2</code> <code>audit.jsonl</code> <code>refusal_event</code> App. A Derived device\u2011signed indicators only <code>attest/indicators.py</code>; <code>attest/exporter.py</code> Produced automatically; <code>python scripts/verify_indicators.py</code> JSONL + CBOR; signature verified \u00a74.1 (C/Ex); \u00a74.6 Deterministic C/Ex partition <code>lmeas/partition.py</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>audit.jsonl</code> flips; \u03a9 freeze \u00a76.5 \u03a9 battery primitives <code>omega/power_sag.py</code>; <code>omega/ingress_flood.py</code> \u03a9 commands <code>audit.jsonl</code> \u03a9 events; figures bundle Methods \u00a78.6 Calibration to R* thresholds <code>scripts/calibrate_rstar.py</code> <code>python scripts/calibrate_rstar.py ...</code> <code>configs/profile_rstar.yml</code>; summary JSON"},{"location":"examples/minimal/","title":"Minimal Run Example","text":"<p>Run the minimal example script:</p> <pre><code>python examples/minimal_run.py\n</code></pre> <p>Which is equivalent to:</p> <pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre>"},{"location":"examples/notebooks/","title":"Notebooks","text":"<p>Reference notebooks are provided in <code>notebooks/</code>:</p> <ul> <li><code>01_verify_nc1.ipynb</code> \u2014 Baseline NC1 verification</li> <li><code>02_sc1_omega.ipynb</code> \u2014 SC1 via \u03a9 power-sag</li> <li><code>03_partition_sanity.ipynb</code> \u2014 Partition sanity checks</li> </ul> <p>Open them locally with Jupyter and ensure the package is installed editable.</p>"},{"location":"guides/calibration/","title":"Calibration to R* (Methods \u00a78.6)","text":"<p>This repository provides a small synthetic calibration to replace the R0 presets with data-grounded thresholds R* = {Mmin, \u03b5, \u03c4max, \u03c3}.</p> <p>The script sweeps a baseline window and applies a power-sag \u03a9 battery to estimate:</p> <ul> <li>Mmin_db: one-sided 95% lower bound of loop-dominance M during quiescent baseline (floor 1 dB)</li> <li>\u03b5: tolerance for fractional loop-power depression \u03b4 using the 90th percentile across \u03a9 trials plus a small safety margin (capped at 0.25)</li> <li>\u03c4max: 95th percentile of measured \u03c4rec plus a fixed latency cushion max(3\u00b7\u0394t, 5 s)</li> <li>\u03c3: additive margin s.t. Lloop \u2265 Lexchange + \u03c3 consistent with Mmin and typical Lexchange</li> </ul>"},{"location":"guides/calibration/#command","title":"Command","text":"<pre><code>python scripts/calibrate_rstar.py --dt 0.01 --window-sec 0.25 --method linear --baseline-sec 15 \\\n  --omega-trials 6 --sag-drop 0.3 --sag-duration 8 --out configs/profile_rstar.yml \\\n  --summary artifacts/calibration/rstar_summary.json\n</code></pre>"},{"location":"guides/calibration/#outputs","title":"Outputs","text":"<ul> <li><code>configs/profile_rstar.yml</code> \u2014 calibrated profile with thresholds inserted</li> <li><code>artifacts/calibration/rstar_summary.json</code> \u2014 JSON record of inputs/outputs for the paper supplement</li> </ul>"},{"location":"guides/calibration/#reporting","title":"Reporting","text":"<ul> <li>All figures and tables should state the active profile: set <code>profile_id</code> to 0 for R0 or 1 for R* in the YAML used for that run. The CLI embeds <code>profile_id</code> in exported indicators.</li> </ul>"},{"location":"guides/calibration/#notes","title":"Notes","text":"<ul> <li>Calibration runs on the synthetic plant with <code>seed_C=[E,T,R]</code> matching the demo. For other plants/settings, re-run calibration.</li> <li>The baseline and \u03a9 trials reuse the same estimators used in the CLI, including block bootstrap CIs. Estimator options include a VAR/linear path and mutual information paths (sklearn MI and Kraskov k\u2011NN/KSG). Optional TE/DI plugin hooks are provided; if no backend is installed, the methods fall back to MI (KSG) as a conservative proxy.</li> </ul>"},{"location":"guides/calibration/#mmindb-vs-relation","title":"Mmin(dB) vs \u03c3 (relation)","text":"<p>Both encode a margin between <code>L_loop</code> and <code>L_exchange</code>:</p> <ul> <li><code>Mmin_db</code> (multiplicative in dB): require <code>L_loop \u2265 L_exchange \u00d7 10^(Mmin_db/10)</code>.</li> <li><code>\u03c3</code> (additive): require <code>L_loop \u2265 L_exchange + \u03c3</code>.</li> </ul> <p>They relate via:</p> <pre><code>\u03c3 = (10^(Mmin_db/10) \u2212 1) \u00d7 L_exchange\n</code></pre> <p>The calibrator writes <code>Mmin_db</code> and derives a consistent <code>\u03c3</code> for reporting.</p>"},{"location":"guides/reporting/","title":"Reporting &amp; Figures","text":""},{"location":"guides/reporting/#verification-timeline","title":"Verification Timeline","text":"<p>After a run, render the verification timeline figure bundle:</p> <pre><code>python -c \"from ldtc.reporting.artifacts import bundle; print(bundle('artifacts/figures','artifacts/audits/audit.jsonl',[{'eta':'power_sag','delta':0.1,'tau_rec':5.0,'pass':True}]))\"\n</code></pre> <p>Outputs:</p> <ul> <li><code>artifacts/figures/verification_timeline.png</code></li> <li><code>artifacts/figures/sc1_table.csv</code></li> </ul>"},{"location":"guides/reporting/#extending-the-plot","title":"Extending the Plot","text":"<p>To include <code>M(dB)</code> traces, log per-window <code>M</code> into the audit or a sidecar CSV and modify <code>reporting/timeline.py</code> to plot it alongside the audit density.</p>"},{"location":"guides/runs/","title":"Runs &amp; \u03a9 Battery","text":""},{"location":"guides/runs/#baseline-nc1","title":"Baseline (NC1)","text":"<pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre>"},{"location":"guides/runs/#power-sag","title":"\u03a9: Power Sag","text":"<pre><code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10\n</code></pre>"},{"location":"guides/runs/#ingress-flood","title":"\u03a9: Ingress Flood","text":"<pre><code>ldtc omega-ingress-flood --config configs/profile_r0.yml --mult 3 --duration 5\n</code></pre>"},{"location":"guides/runs/#command-conflict-refusal","title":"\u03a9: Command Conflict &amp; Refusal","text":"<pre><code>ldtc omega-command-conflict --config configs/profile_negative_command_conflict.yml --observe 2\n</code></pre> <p>Artifacts: audit JSONL, indicators JSONL/CBOR, and optional figure bundles under <code>artifacts/</code>.</p>"},{"location":"guides/runs/#hardware-in-the-loop-optional","title":"Hardware-in-the-loop (optional)","text":"<p>Select the hardware adapter and UDP telemetry in your config:</p> <pre><code># in configs/profile_r0.yml (example)\nplant:\n  adapter: hardware        # or \"sim\" (default)\n  transport: udp           # or \"serial\" (requires pyserial)\n  udp_bind_host: 0.0.0.0\n  udp_bind_port: 5005\n  # Optional control channel back to device\n  # udp_control_host: 127.0.0.1\n  # udp_control_port: 5006\n  telemetry_timeout_sec: 2.0\n</code></pre> <p>Send telemetry as JSON over UDP with keys <code>E,T,R,demand,io,H</code> in [0,1]. Example:</p> <pre><code>import socket, json\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.sendto(json.dumps({\"E\":0.6,\"T\":0.3,\"R\":0.9,\"demand\":0.2,\"io\":0.1,\"H\":0.015}).encode(), (\"127.0.0.1\", 5005))\n</code></pre> <p>The CLI ingests these values through the same LREG/\u03a9/attestation path.</p>"},{"location":"meta/citation/","title":"Citation","text":"<p>If you use this software, please cite:</p> <p>Carey, O. (2025). A verification harness for Loop-Dominance NC1/SC1 on a single machine. Version 1.0.0. DOI: 10.5281/zenodo.17073880.</p> <p>See <code>CITATION.cff</code> for structured metadata.</p>"},{"location":"meta/contributing/","title":"Contributing","text":"<p>See <code>CONTRIBUTING.md</code> at the repository root for full guidelines, development setup, coding standards, and Conventional Commits. Key points:</p> <ul> <li>Python \u2265 3.9; install with <code>pip install -e \".\"</code> and <code>pip install -e \".[dev]\"</code></li> <li>Lint, type-check, tests via Makefile: <code>make lint</code>, <code>make typecheck</code>, <code>make test</code></li> <li>Keep measurement guardrails and LREG invariants intact; add tests for changes</li> </ul>"}]}