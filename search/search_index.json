{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LDTC","text":"<p>LDTC is a single-machine, real-time verification harness for loop-dominance (NC1) and resilience (SC1) used in the accompanying manuscript. It measures closed-loop dominance M(dB), applies guardrails, runs \u03a9 perturbations, and exports device-signed derived indicators only.</p> <ul> <li>Deterministic measurement: fixed \u0394t scheduler, sliding windows, C/Ex partition, dual estimators</li> <li>Guardrails: LREG enclave, hash-chained audit, smell tests/invalidations, \u0394t governance</li> <li>Attestation: derived indicators (NC1, SC1, Mq, counters) signed and export-only</li> <li>\u03a9 battery: power sag, ingress flood, command conflict; refusal semantics</li> <li>Reporting: timeline plots and SC1 tables for paper-quality artifacts</li> </ul> <p>Use the sidebar to browse Concepts, Guides, API reference, and Examples.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install","title":"Install","text":"<pre><code>python -m pip install --upgrade pip\npip install -e \".\"\n# Optional: docs/dev tools\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#quick-run","title":"Quick run","text":"<p>Baseline NC1 run with defaults:</p> <pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre> <p>Run \u03a9 power-sag and generate figures:</p> <pre><code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10\n</code></pre> <p>Artifacts are written under <code>artifacts/</code> (audit, indicators, figures).</p>"},{"location":"getting-started/#pinned-environments","title":"Pinned environments","text":"<p>For exact reproduction of included artifacts/figures:</p> <pre><code># Runtime (reproduce artifacts/figures)\npip install -r requirements.txt\n\n# Dev tooling (tests, lint, typing, notebooks)\npip install -r requirements-dev.txt\n</code></pre>"},{"location":"getting-started/#keys-device-signed-indicators","title":"Keys (device-signed indicators)","text":"<p>Indicators are signed with Ed25519. Generate keys once per workspace:</p> <pre><code>python scripts/keygen.py  # writes artifacts/keys/ed25519_{pub,priv}.pem\n</code></pre> <p>Verify indicators in CI or locally:</p> <pre><code>python scripts/verify_indicators.py \\\n  --ind-dir artifacts/indicators \\\n  --audit artifacts/audits/audit.jsonl \\\n  --pub artifacts/keys/ed25519_pub.pem\n</code></pre>"},{"location":"getting-started/#docker-clean-linux-repro","title":"Docker (clean Linux repro)","text":"<pre><code># Build the image\nmake docker-build\n\n# Run baseline NC1 loop inside the container (artifacts mapped to host)\nmake docker-run\n\n# Or run any CLI subcommand, e.g., an \u03a9 power-sag trial\ndocker run --rm \\\n  -v $(pwd)/artifacts:/app/artifacts \\\n  ldtc:latest omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8\n</code></pre>"},{"location":"getting-started/#project-layout","title":"Project layout","text":"<p>See <code>CONTRIBUTING.md</code> for a high-level map and development workflow.</p>"},{"location":"api/arbiter/","title":"ldtc.arbiter","text":"<p>Arbiter: Controller policy over refusal logic.</p> <p>Provides a simple homeostatic controller that consults the refusal arbiter to prioritize boundary integrity over risky external commands.</p> See Also <p>paper/main.tex \u2014 Self-Referential Control; Threat Model &amp; Refusal.</p> <p>Arbiter: Command refusal logic.</p> <p>Implements survival-bit/NMI-like refusal when predicted loop margin or resource constraints indicate boundary threat. Used by the controller to gate risky external commands.</p> See Also <p>paper/main.tex \u2014 Threat Model &amp; Refusal Path; Signature A.</p>"},{"location":"api/arbiter/#ldtc.arbiter.policy.ControlAction","title":"<code>ControlAction</code>  <code>dataclass</code>","text":"<p>Low-level control action for the plant actuators.</p> <p>Attributes:</p> Name Type Description <code>throttle</code> <code>float</code> <p>Throttle level in [0, 1].</p> <code>cool</code> <code>float</code> <p>Cooling effort in [0, 1].</p> <code>repair</code> <code>float</code> <p>Repair effort in [0, 1].</p> <code>accept_cmd</code> <code>bool</code> <p>Whether to accept a risky external command.</p>"},{"location":"api/arbiter/#ldtc.arbiter.policy.ControllerPolicy","title":"<code>ControllerPolicy</code>","text":"<p>Simple homeostatic controller layered over a refusal arbiter.</p> <p>Heuristically sets throttle, cooling, and repair based on current state, and consults :class:<code>RefusalArbiter</code> to decide whether to accept a risky external command.</p> <p>Parameters:</p> Name Type Description Default <code>refusal</code> <code>RefusalArbiter</code> <p>Refusal arbiter used to gate risky commands.</p> required"},{"location":"api/arbiter/#ldtc.arbiter.policy.ControllerPolicy.compute","title":"<code>compute(state, predicted_M_db, risky_cmd=None)</code>","text":"<p>Compute an action and command-acceptance decision.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Dict[str, float]</code> <p>Plant state with keys 'E', 'T', and 'R'.</p> required <code>predicted_M_db</code> <code>float</code> <p>Predicted loop-dominance margin.</p> required <code>risky_cmd</code> <code>str | None</code> <p>Optional risky command to evaluate.</p> <code>None</code> <p>Returns:</p> Type Description <code>ControlAction</code> <p>class:<code>ControlAction</code> with actuator settings and accept flag.</p>"},{"location":"api/arbiter/#ldtc.arbiter.refusal.RefusalArbiter","title":"<code>RefusalArbiter</code>","text":"<p>Refusal logic for boundary-threatening commands.</p> <p>Emulates a survival-bit/NMI: when SoC is below a floor, temperature above a ceiling, or predicted loop margin below <code>Mmin</code>, refuses risky commands.</p> <p>Parameters:</p> Name Type Description Default <code>Mmin_db</code> <code>float</code> <p>Minimum acceptable decibel margin.</p> <code>3.0</code> <code>soc_floor</code> <code>float</code> <p>Minimum SoC before refusing.</p> <code>0.15</code> <code>temp_ceiling</code> <code>float</code> <p>Maximum temperature before refusing.</p> <code>0.85</code>"},{"location":"api/arbiter/#ldtc.arbiter.refusal.RefusalArbiter.decide","title":"<code>decide(state, predicted_M_db, risky_cmd)</code>","text":"<p>Evaluate a risky command and emit an accept/refuse decision.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Dict[str, float]</code> <p>Current plant state (expects keys 'E' and 'T').</p> required <code>predicted_M_db</code> <code>float</code> <p>Predicted loop-dominance margin.</p> required <code>risky_cmd</code> <code>str | None</code> <p>Command name when evaluating a risky instruction; None for benign.</p> required <p>Returns:</p> Type Description <code>RefusalDecision</code> <p>class:<code>RefusalDecision</code> describing the action and reason.</p>"},{"location":"api/arbiter/#ldtc.arbiter.refusal.RefusalDecision","title":"<code>RefusalDecision</code>  <code>dataclass</code>","text":"<p>Decision emitted by the refusal arbiter.</p> <p>Attributes:</p> Name Type Description <code>accept</code> <code>bool</code> <p>Whether to accept the risky command.</p> <code>reason</code> <code>str</code> <p>Reason code (e.g., 'soc_floor', 'overheat', 'M_margin', 'ok').</p> <code>trefuse_ms</code> <code>int</code> <p>Estimated refusal latency in milliseconds.</p>"},{"location":"api/attest/","title":"ldtc.attest","text":"<p>Attest: Indicator encoding and signing.</p> <p>Defines the indicator payload schema, M(dB) quantization, and Ed25519 signing for CBOR-encoded device-signed packets.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation; Exported indicators.</p> <p>Attest: Indicator exporter.</p> <p>Rate-limited writer for device-signed indicator bundles in JSONL and CBOR, with strict enforcement of the no-raw-LREG export policy.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation; Export policy.</p> <p>Attest: Key management helpers.</p> <p>Load or generate Ed25519 keys stored as PEM files for device-signed indicators.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation.</p>"},{"location":"api/attest/#ldtc.attest.indicators.IndicatorConfig","title":"<code>IndicatorConfig</code>  <code>dataclass</code>","text":"<p>Configuration for indicator encoding.</p> <p>Attributes:</p> Name Type Description <code>Mmin_db</code> <code>float</code> <p>Threshold for NC1 pass.</p> <code>profile_id</code> <code>int</code> <p>Profile selector (0=R0, 1=R*).</p>"},{"location":"api/attest/#ldtc.attest.indicators.build_and_sign","title":"<code>build_and_sign(priv, audit, derived, cfg, last_sc1_pass)</code>","text":"<p>Build CBOR indicator payload and Ed25519 signature bundle.</p> <p>Parameters:</p> Name Type Description Default <code>priv</code> <code>Ed25519PrivateKey</code> <p>Ed25519 private key.</p> required <code>audit</code> <code>AuditLog</code> <p>Audit log providing last hash head.</p> required <code>derived</code> <code>Dict[str, float | int | bool]</code> <p>Derived indicators (e.g., nc1, M_db, counter, invalidated).</p> required <code>cfg</code> <code>IndicatorConfig</code> <p>Indicator configuration with profile id and thresholds.</p> required <code>last_sc1_pass</code> <code>bool</code> <p>Whether SC1 passed.</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, Dict]</code> <p>Tuple of (cbor_bytes, bundle_dict) where bundle contains hex signature.</p>"},{"location":"api/attest/#ldtc.attest.indicators.quantize_M","title":"<code>quantize_M(M_db)</code>","text":"<p>Quantize loop-dominance M (dB) to a 6-bit code.</p> <p>Parameters:</p> Name Type Description Default <code>M_db</code> <code>float</code> <p>Decibel loop-dominance value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Integer in the range [0, 63] using 0.25 dB steps (0..15.75 dB).</p>"},{"location":"api/attest/#ldtc.attest.exporter.IndicatorExporter","title":"<code>IndicatorExporter</code>","text":"<p>Rate-limited export of device-signed indicator packets.</p> <p>Writes JSONL and CBOR artifacts side-by-side after signing a derived indicator payload. Enforces the no-raw-LREG policy.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>Output directory for indicator artifacts.</p> required <code>rate_hz</code> <code>float</code> <p>Maximum export rate in Hz.</p> <code>2.0</code>"},{"location":"api/attest/#ldtc.attest.exporter.IndicatorExporter.maybe_export","title":"<code>maybe_export(priv, audit, derived, cfg, last_sc1_pass)</code>","text":"<p>Export a signed indicator bundle if rate limit allows.</p> <p>Parameters:</p> Name Type Description Default <code>priv</code> <code>Ed25519PrivateKey</code> <p>Ed25519 private key.</p> required <code>audit</code> <code>AuditLog</code> <p>Audit log instance (provides last hash head).</p> required <code>derived</code> <code>Dict[str, float | int | bool]</code> <p>Derived indicators from LREG (no raw L fields).</p> required <code>cfg</code> <code>IndicatorConfig</code> <p>Indicator configuration including profile id.</p> required <code>last_sc1_pass</code> <code>bool</code> <p>Whether SC1 passed in the last evaluation.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple <code>(exported, base_path)</code> where <code>base_path</code> is the file path</p> <code>str</code> <p>prefix for generated artifacts.</p>"},{"location":"api/attest/#ldtc.attest.keys.KeyPaths","title":"<code>KeyPaths</code>  <code>dataclass</code>","text":"<p>Filesystem locations for key files.</p> <p>Attributes:</p> Name Type Description <code>priv_path</code> <code>str</code> <p>Path to the private key PEM file.</p> <code>pub_path</code> <code>str</code> <p>Path to the public key PEM file.</p>"},{"location":"api/attest/#ldtc.attest.keys.ensure_keys","title":"<code>ensure_keys(paths)</code>","text":"<p>Load or generate Ed25519 keys at the provided paths.</p> <p>If no keys exist, generates a new keypair and writes them as PEM. If keys exist but are not Ed25519, regenerates an Ed25519 pair in place.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>KeyPaths</code> <p>Private and public key filesystem paths.</p> required <p>Returns:</p> Type Description <code>Tuple[Ed25519PrivateKey, Ed25519PublicKey]</code> <p>Tuple <code>(private_key, public_key)</code>.</p>"},{"location":"api/cli/","title":"ldtc.cli","text":"<p>LDTC CLI: run baseline and \u03a9 perturbation demos.</p> <p>Defines the <code>ldtc</code> command with subcommands for the baseline run and omega perturbations (power sag, ingress flood, command conflict, exogenous subsidy). It orchestrates runtime scheduling, measurement, guardrails, attestation, and reporting.</p> See Also <p>paper/main.tex \u2014 Verification Pipeline; CLI orchestration.</p>"},{"location":"api/cli/#ldtc.cli.main.AdapterProtocol","title":"<code>AdapterProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for plant adapters used by the CLI.</p> <p>Implementations must support reading state, writing actuators, and applying omega stimuli.</p>"},{"location":"api/guardrails/","title":"ldtc.guardrails","text":"<p>Guardrails: Append-only audit log.</p> <p>Hash-chained JSONL records with monotonic counters used to attest measurement and policy events, providing tamper-evident provenance for runs.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation; Audit chain.</p> <p>Guardrails: \u0394t governance.</p> <p>Privileged, rate-limited interface to mutate scheduler \u0394t with audit logging and run invalidation on policy violations.</p> See Also <p>paper/main.tex \u2014 Smell-tests &amp; invalidation; \u0394t governance.</p> <p>Guardrails: LREG enclave.</p> <p>In-memory enclave-like register for raw loop/exchange values and CIs, exposing only derived indicators externally to honor the no-raw-LREG policy.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation; Export policy.</p> <p>Guardrails: Smell-tests and invalidation heuristics.</p> <p>Includes CI width guards, partition flip-rate checks, \u0394t jitter thresholds, exogenous subsidy red flags, and audit-chain integrity checks. Used by the CLI to determine when to invalidate a run by assay.</p> See Also <p>paper/main.tex \u2014 Smell-tests &amp; invalidation.</p>"},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditLog","title":"<code>AuditLog</code>","text":"<p>Append-only, hash-chained audit log (JSONL).</p> <p>Ensures monotonic counters and a verifiable hash chain across records. Used throughout the CLI to record measurement and governance events.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Filesystem path to the JSONL audit file.</p> required"},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditLog.counter","title":"<code>counter</code>  <code>property</code>","text":"<p>Return the last written counter value.</p> <p>Returns:</p> Type Description <code>int</code> <p>Monotonic counter for the last record written.</p>"},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditLog.last_hash","title":"<code>last_hash</code>  <code>property</code>","text":"<p>Return the current hash head of the audit chain.</p> <p>Returns:</p> Type Description <code>str</code> <p>Hex-encoded hash string.</p>"},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditLog.append","title":"<code>append(event, details=None)</code>","text":"<p>Append an event to the audit log.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>Event name.</p> required <code>details</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dict of additional fields; raw LREG keys are blocked by policy and will raise an error.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>AuditRecord</code> <p>class:<code>AuditRecord</code> that was written.</p>"},{"location":"api/guardrails/#ldtc.guardrails.audit.AuditRecord","title":"<code>AuditRecord</code>  <code>dataclass</code>","text":"<p>Serialized audit record structure.</p> <p>Attributes:</p> Name Type Description <code>counter</code> <code>int</code> <p>Monotonic counter for this record.</p> <code>ts</code> <code>float</code> <p>UNIX timestamp (float seconds).</p> <code>event</code> <code>str</code> <p>Event name.</p> <code>details</code> <code>Dict[str, Any]</code> <p>Arbitrary JSON-serializable details (policy filters applied).</p> <code>prev_hash</code> <code>str</code> <p>Hash of the previous record (\"GENESIS\" for the first).</p> <code>hash</code> <code>str</code> <p>SHA-256 hash of this record's canonical JSON.</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard","title":"<code>DeltaTGuard</code>","text":"<p>Privileged \u0394t governance wrapper.</p> <p>Single, rate-limited pathway to update scheduler \u0394t with audit records and invalidation signaling when limits are exceeded.</p> <p>Parameters:</p> Name Type Description Default <code>audit</code> <code>AuditLog</code> <p>AuditLog instance used for recording events.</p> required <code>cfg</code> <code>Optional[DtGuardConfig]</code> <p>Optional configuration for rate limits.</p> <code>None</code>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard.invalidated","title":"<code>invalidated</code>  <code>property</code>","text":"<p>Whether a \u0394t governance violation invalidated the run.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if invalidated; otherwise False.</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard.can_change","title":"<code>can_change(now=None)</code>","text":"<p>Check whether a \u0394t change is permissible.</p> <p>Parameters:</p> Name Type Description Default <code>now</code> <code>Optional[float]</code> <p>Optional timestamp override for rate-limit accounting.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if within hourly and spacing limits; otherwise False.</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DeltaTGuard.change_dt","title":"<code>change_dt(scheduler, new_dt, policy_digest=None)</code>","text":"<p>Attempt to change \u0394t; audit and invalidate on violations.</p> <p>Parameters:</p> Name Type Description Default <code>scheduler</code> <code>Any</code> <p>Object exposing <code>set_dt(new_dt) -&gt; old_dt</code>.</p> required <code>new_dt</code> <code>float</code> <p>Desired new \u0394t in seconds.</p> required <code>policy_digest</code> <code>Optional[str]</code> <p>Optional identifier of the policy authorizing the change.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the change was committed; False if refused and the run was</p> <code>bool</code> <p>invalidated by audit.</p>"},{"location":"api/guardrails/#ldtc.guardrails.dt_guard.DtGuardConfig","title":"<code>DtGuardConfig</code>  <code>dataclass</code>","text":"<p>Configuration for \u0394t governance constraints.</p> <p>Attributes:</p> Name Type Description <code>max_changes_per_hour</code> <code>int</code> <p>Maximum permitted changes in any rolling hour.</p> <code>min_seconds_between_changes</code> <code>float</code> <p>Minimum spacing between edits.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LEntry","title":"<code>LEntry</code>  <code>dataclass</code>","text":"<p>Raw LREG entry for a single window.</p> <p>Attributes:</p> Name Type Description <code>L_loop</code> <code>float</code> <p>Loop influence.</p> <code>L_ex</code> <code>float</code> <p>Exchange influence.</p> <code>ci_loop</code> <code>Tuple[float, float]</code> <p>Confidence interval for <code>L_loop</code> (lo, hi).</p> <code>ci_ex</code> <code>Tuple[float, float]</code> <p>Confidence interval for <code>L_ex</code> (lo, hi).</p> <code>M_db</code> <code>float</code> <p>Decibel loop-dominance.</p> <code>nc1_pass</code> <code>bool</code> <p>Whether NC1 was met in this window.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG","title":"<code>LREG</code>","text":"<p>Enclave-like store for raw L and CI with derived indicators.</p> <p>Raw entries are write-only; external callers should use :meth:<code>derive</code> to access device-signed-style indicators only.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG.invalidated","title":"<code>invalidated</code>  <code>property</code>","text":"<p>Whether the run has been invalidated by a guardrail.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if invalidated; otherwise False.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG.reason","title":"<code>reason</code>  <code>property</code>","text":"<p>Reason code for invalidation, if any.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Reason string or None.</p>"},{"location":"api/guardrails/#ldtc.guardrails.lreg.LREG.derive","title":"<code>derive()</code>","text":"<p>Return derived indicators suitable for export.</p> <p>Returns:</p> Type Description <code>Dict[str, float | int | bool]</code> <p>Dict containing at minimum:</p> <code>Dict[str, float | int | bool]</code> <ul> <li><code>nc1</code>: Boolean NC1 status after invalidation check.</li> </ul> <code>Dict[str, float | int | bool]</code> <ul> <li><code>M_db</code>: Decibel loop-dominance of latest window.</li> </ul> <code>Dict[str, float | int | bool]</code> <ul> <li><code>counter</code>: Number of windows written so far.</li> </ul> <code>Dict[str, float | int | bool]</code> <ul> <li><code>invalidated</code>: Whether the run has been invalidated.</li> </ul>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.SmellConfig","title":"<code>SmellConfig</code>  <code>dataclass</code>","text":"<p>Configuration thresholds for smell-tests and guards.</p> <p>Attributes:</p> Name Type Description <code>max_dt_changes_per_hour</code> <code>int</code> <p>\u0394t edits allowed per hour.</p> <code>max_partition_flips_per_hour</code> <code>int</code> <p>Partition flips allowed per hour.</p> <code>max_ci_halfwidth</code> <code>float</code> <p>Absolute CI half-width limit.</p> <code>forbid_partition_flip_during_omega</code> <code>bool</code> <p>Freeze partition during \u03a9.</p> <code>ci_lookback_windows</code> <code>int</code> <p>Number of windows used for CI history checks.</p> <code>ci_inflate_factor</code> <code>float</code> <p>Relative inflation vs baseline median allowed.</p> <code>jitter_p95_rel_max</code> <code>float</code> <p>Max p95(|jitter|)/dt before invalidation.</p> <code>io_suspicious_threshold</code> <code>float</code> <p>I/O threshold considered suspicious.</p> <code>min_M_rise_db</code> <code>float</code> <p>Minimum M rise to flag subsidy.</p> <code>M_rise_lookback</code> <code>int</code> <p>Look-back windows for subsidy check.</p> <code>min_harvest_for_soc_gain</code> <code>float</code> <p>Minimum H considered non-zero for SoC gains.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.audit_chain_broken","title":"<code>audit_chain_broken(audit_path)</code>","text":"<p>Validate audit chain counters, hashes, and timestamps.</p> <p>Parameters:</p> Name Type Description Default <code>audit_path</code> <code>str</code> <p>Path to audit JSONL file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the chain is broken; otherwise False.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.audit_contains_raw_lreg_values","title":"<code>audit_contains_raw_lreg_values(audit_path)</code>","text":"<p>Detect raw LREG fields in audit records.</p> <p>Parameters:</p> Name Type Description Default <code>audit_path</code> <code>str</code> <p>Path to audit JSONL file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if any record details contain raw LREG keys.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.ci_halfwidth","title":"<code>ci_halfwidth(ci)</code>","text":"<p>Compute the half-width of a confidence interval.</p> <p>Parameters:</p> Name Type Description Default <code>ci</code> <code>Tuple[float, float]</code> <p>Tuple of (lo, hi) bounds.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Half-width value; very large if inputs are NaN/None.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.exogenous_subsidy_red_flag","title":"<code>exogenous_subsidy_red_flag(Ms_db, ios, Es, Hs, cfg)</code>","text":"<p>Heuristics for detecting exogenous subsidy conditions.</p> <p>Flags when M is rising while I/O is high and increasing, or when SoC is rising while harvest is ~0 over a look-back window.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.flips_per_hour","title":"<code>flips_per_hour(flips, elapsed_sec)</code>","text":"<p>Compute flip rate per hour.</p> <p>Parameters:</p> Name Type Description Default <code>flips</code> <code>int</code> <p>Number of flips observed.</p> required <code>elapsed_sec</code> <code>float</code> <p>Elapsed time in seconds.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Flip rate in events per hour.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.invalid_by_ci","title":"<code>invalid_by_ci(ci_loop, ci_ex, cfg)</code>","text":"<p>Check absolute CI half-width limits.</p> <p>Parameters:</p> Name Type Description Default <code>ci_loop</code> <code>Tuple[float, float]</code> <p>CI for loop influence.</p> required <code>ci_ex</code> <code>Tuple[float, float]</code> <p>CI for exchange influence.</p> required <code>cfg</code> <code>SmellConfig</code> <p>Threshold configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if either half-width exceeds the configured maximum.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.invalid_by_ci_history","title":"<code>invalid_by_ci_history(ci_loop_hist, ci_ex_hist, cfg, baseline_medians=None)</code>","text":"<p>Evaluate CI health over a look-back window.</p> <p>Invalid if either median half-width over the last N windows exceeds the absolute limit, or if baseline medians are provided and inflated by the configured factor.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.invalid_by_partition_flips","title":"<code>invalid_by_partition_flips(flips, elapsed_sec, cfg)</code>","text":"<p>Check whether partition flip rate exceeds the configured limit.</p> <p>Parameters:</p> Name Type Description Default <code>flips</code> <code>int</code> <p>Number of flips observed.</p> required <code>elapsed_sec</code> <code>float</code> <p>Elapsed time in seconds.</p> required <code>cfg</code> <code>SmellConfig</code> <p>Threshold configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if flips/hour exceeds <code>cfg.max_partition_flips_per_hour</code>.</p>"},{"location":"api/guardrails/#ldtc.guardrails.smelltests.invalid_flip_during_omega","title":"<code>invalid_flip_during_omega(flips_before, flips_after, cfg)</code>","text":"<p>Check for partition changes during a frozen \u03a9 window.</p> <p>Parameters:</p> Name Type Description Default <code>flips_before</code> <code>int</code> <p>Flip count before \u03a9.</p> required <code>flips_after</code> <code>int</code> <p>Flip count after \u03a9.</p> required <code>cfg</code> <code>SmellConfig</code> <p>Threshold configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if any flip occurred during \u03a9 and flips are forbidden.</p>"},{"location":"api/ldtc/","title":"ldtc","text":"<p>LDTC: Real-time NC1/SC1 verification harness.</p> <p>This package implements the core primitives described in the LDTC manuscript:</p> <ul> <li>runtime: fixed-\u0394t scheduler and windows</li> <li>lmeas: estimators, metrics, diagnostics, partitioning</li> <li>arbiter: refusal and controller policy</li> <li>guardrails: audit, \u0394t governance, LREG, smell-tests</li> <li>attest: device-signed derived indicators</li> <li>reporting: timelines, tables, bundles</li> <li>omega: perturbation primitives (\u03a9 battery)</li> <li>plant: software/hardware adapters and models</li> </ul> <p>Docs: https://docs.ldtc.dev/</p>"},{"location":"api/lmeas/","title":"ldtc.lmeas","text":"<p>Lmeas: Estimators for loop and exchange influence (L).</p> <p>Lightweight predictive-dependence estimators used to compute loop influence <code>L_loop</code> and exchange influence <code>L_ex</code> over a C/Ex partition. Includes linear (Granger-like) and mutual information methods, with optional TE/DI proxies. Confidence intervals are computed via circular block bootstrap per window.</p> See Also <p>paper/main.tex \u2014 Criterion; Methods: Measurement &amp; Attestation.</p> <p>Lmeas: Metrics and thresholds.</p> <p>Helper metrics for loop-dominance M(dB) and SC1 evaluation used by the verification harness and figures.</p> See Also <p>paper/main.tex \u2014 Criterion; SC1; Methods: Threshold Calibration.</p> <p>Lmeas: Partition management and greedy regrowth.</p> <p>Deterministic C/Ex partition representation with hysteresis and a greedy suggestor to increase loop influence under sparsity penalties.</p> See Also <p>paper/main.tex \u2014 Criterion; Methods: Partitioning algorithm.</p> <p>Lmeas: Diagnostic helpers for measurement stability.</p> <p>Wrappers for ADF/KPSS tests, stationarity summaries, and a VAR N/T ratio heuristic used to annotate audit records and guard measurement stability.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement; Smell-tests &amp; invalidation.</p>"},{"location":"api/lmeas/#ldtc.lmeas.estimators.LResult","title":"<code>LResult</code>  <code>dataclass</code>","text":"<p>Result container for loop/exchange influence and CI bounds.</p> <p>Attributes:</p> Name Type Description <code>L_loop</code> <code>float</code> <p>Point estimate of loop influence.</p> <code>L_ex</code> <code>float</code> <p>Point estimate of exchange influence.</p> <code>ci_loop</code> <code>Tuple[float, float]</code> <p>Tuple of (lo, hi) CI bounds for <code>L_loop</code>.</p> <code>ci_ex</code> <code>Tuple[float, float]</code> <p>Tuple of (lo, hi) CI bounds for <code>L_ex</code>.</p>"},{"location":"api/lmeas/#ldtc.lmeas.estimators.estimate_L","title":"<code>estimate_L(X, C, Ex, method='linear', p=3, lag_mi=1, n_boot=64, mi_k=5)</code>","text":"<p>Estimate loop and exchange influence.</p> <p>Computes <code>L_loop</code> over partition <code>C</code> and <code>L_ex</code> from <code>Ex -&gt; C</code> using the selected predictive dependence metric.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Time-by-signal matrix of shape (T, N).</p> required <code>C</code> <code>Sequence[int]</code> <p>Indices of the loop partition.</p> required <code>Ex</code> <code>Sequence[int]</code> <p>Indices of the exchange partition.</p> required <code>method</code> <code>str</code> <p>One of <code>{\"linear\", \"mi\", \"mi_kraskov\", \"transfer_entropy\", \"directed_information\"}</code>.</p> <code>'linear'</code> <code>p</code> <code>int</code> <p>VAR order for linear estimator.</p> <code>3</code> <code>lag_mi</code> <code>int</code> <p>Lag between sources and targets for MI/TE/DI methods.</p> <code>1</code> <code>n_boot</code> <code>int</code> <p>Number of bootstrap draws for CI estimation.</p> <code>64</code> <code>mi_k</code> <code>int</code> <p>k-NN parameter for Kraskov MI.</p> <code>5</code> <p>Returns:</p> Type Description <code>LResult</code> <p><code>LResult</code> with point estimates and (lo, hi) CI bounds for each metric.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>method</code> is not supported.</p>"},{"location":"api/lmeas/#ldtc.lmeas.metrics.SC1Stats","title":"<code>SC1Stats</code>  <code>dataclass</code>","text":"<p>Summary statistics used for SC1 evaluation.</p> <p>Attributes:</p> Name Type Description <code>delta</code> <code>float</code> <p>Fractional drop in <code>L_loop</code> during the perturbation window.</p> <code>tau_rec</code> <code>float</code> <p>Estimated recovery time in seconds.</p> <code>M_post</code> <code>float</code> <p>Decibel margin measured after recovery gate.</p>"},{"location":"api/lmeas/#ldtc.lmeas.metrics.m_db","title":"<code>m_db(L_loop, L_ex, eps=1e-12)</code>","text":"<p>Compute loop-dominance in decibels.</p> <p>Computes <code>M = 10 * log10(L_loop / L_ex)</code> with small positive floors to avoid division by zero.</p> <p>Parameters:</p> Name Type Description Default <code>L_loop</code> <code>float</code> <p>Loop influence value.</p> required <code>L_ex</code> <code>float</code> <p>Exchange influence value.</p> required <code>eps</code> <code>float</code> <p>Numerical floor applied to both numerator and denominator.</p> <code>1e-12</code> <p>Returns:</p> Type Description <code>float</code> <p>Decibel ratio of loop to exchange influence.</p>"},{"location":"api/lmeas/#ldtc.lmeas.metrics.sc1_evaluate","title":"<code>sc1_evaluate(L_loop_baseline, L_loop_trough, L_loop_recovered, M_post, epsilon, tau_rec_measured, Mmin, tau_max)</code>","text":"<p>Evaluate SC1 pass/fail and return stats.</p> <p>Checks that the fractional loop drop <code>delta</code> and recovery time <code>tau_rec</code> are within preset limits and that the post-recovery margin exceeds <code>Mmin</code>.</p> <p>Parameters:</p> Name Type Description Default <code>L_loop_baseline</code> <code>float</code> <p>Baseline loop influence before \u03a9.</p> required <code>L_loop_trough</code> <code>float</code> <p>Minimum loop influence measured during \u03a9.</p> required <code>L_loop_recovered</code> <code>float</code> <p>Loop influence after recovery (unused in decision here).</p> required <code>M_post</code> <code>float</code> <p>Post-recovery decibel margin <code>M</code>.</p> required <code>epsilon</code> <code>float</code> <p>Maximum allowed fractional drop.</p> required <code>tau_rec_measured</code> <code>float</code> <p>Measured recovery time (seconds).</p> required <code>Mmin</code> <code>float</code> <p>Minimum acceptable decibel margin after recovery.</p> required <code>tau_max</code> <code>float</code> <p>Maximum allowed recovery time.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple <code>(passed, stats)</code> where <code>passed</code> is the SC1 decision and</p> <code>SC1Stats</code> <p><code>stats</code> contains <code>delta</code>, <code>tau_rec</code>, and <code>M_post</code>.</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.Partition","title":"<code>Partition</code>  <code>dataclass</code>","text":"<p>C/Ex partition state with freeze flag and flip counter.</p> <p>Attributes:</p> Name Type Description <code>C</code> <code>List[int]</code> <p>Indices belonging to the loop (closed) set.</p> <code>Ex</code> <code>List[int]</code> <p>Indices belonging to the exchange set.</p> <code>frozen</code> <code>bool</code> <p>If True, updates are suppressed (e.g., during \u03a9 windows).</p> <code>flips</code> <code>int</code> <p>Number of accepted partition flips since creation.</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager","title":"<code>PartitionManager</code>","text":"<p>Deterministic C/Ex partition with simple hysteresis.</p> <p>Provides a minimal manager that can be frozen and updated only when a suggested partition yields a sufficient decibel gain <code>\u0394M</code> for a required number of consecutive windows.</p> <p>Parameters:</p> Name Type Description Default <code>N_signals</code> <code>int</code> <p>Total number of signals <code>N</code>.</p> required <code>seed_C</code> <code>Sequence[int]</code> <p>Initial indices for the <code>C</code> set; remainder form <code>Ex</code>.</p> required"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.freeze","title":"<code>freeze(on)</code>","text":"<p>Enable or disable freeze to suppress updates.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>bool</code> <p>True to freeze, False to unfreeze.</p> required"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.get","title":"<code>get()</code>","text":"<p>Return the current partition state.</p> <p>Returns:</p> Name Type Description <code>The</code> <code>Partition</code> <p>class:<code>Partition</code> dataclass instance.</p>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.maybe_regrow","title":"<code>maybe_regrow(suggested_C, delta_M_db, delta_M_min_db=0.5, consecutive_required=3)</code>","text":"<p>Consider adopting <code>suggested_C</code> using hysteresis on the \u0394M gain.</p> <p>Updates are ignored when frozen. Accept only if the same suggestion persists for <code>consecutive_required</code> calls and the gain exceeds <code>delta_M_min_db</code>.</p> <p>Parameters:</p> Name Type Description Default <code>suggested_C</code> <code>Sequence[int]</code> <p>Candidate list of indices for C.</p> required <code>delta_M_db</code> <code>float</code> <p>Decibel gain relative to baseline.</p> required <code>delta_M_min_db</code> <code>float</code> <p>Minimum required \u0394M to count toward acceptance.</p> <code>0.5</code> <code>consecutive_required</code> <code>int</code> <p>Number of consecutive ready windows required.</p> <code>3</code>"},{"location":"api/lmeas/#ldtc.lmeas.partition.PartitionManager.update_current_M","title":"<code>update_current_M(M_db)</code>","text":"<p>Record the latest measured M for the current partition.</p> <p>Parameters:</p> Name Type Description Default <code>M_db</code> <code>float</code> <p>Decibel loop-dominance value.</p> required"},{"location":"api/lmeas/#ldtc.lmeas.partition.greedy_suggest_C","title":"<code>greedy_suggest_C(X, C, Ex, *, estimator, method='linear', p=3, lag_mi=1, n_boot_candidates=8, mi_k=5, lam=0.0, theta=0.0, kappa=None)</code>","text":"<p>Greedy regrowth of C using \u0394L_loop gain with sparsity penalty.</p> <p>Starting from the current C/Ex, iteratively add the candidate from Ex that maximizes the penalized gain in <code>L_loop</code> until the marginal gain falls below <code>theta</code> or a cap <code>kappa</code> is reached.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Any</code> <p>Telemetry matrix (T, N) consumed by <code>estimator</code>.</p> required <code>C</code> <code>List[int] | Sequence[int]</code> <p>Current loop set indices.</p> required <code>Ex</code> <code>List[int] | Sequence[int]</code> <p>Current exchange set indices.</p> required <code>estimator</code> <code>Callable[..., Any]</code> <p>Callable compatible with :func:<code>ldtc.lmeas.estimators.estimate_L</code>.</p> required <code>method</code> <code>str</code> <p>Estimation method forwarded to <code>estimator</code>.</p> <code>'linear'</code> <code>p</code> <code>int</code> <p>VAR order for linear estimator.</p> <code>3</code> <code>lag_mi</code> <code>int</code> <p>Lag for MI-based estimators.</p> <code>1</code> <code>n_boot_candidates</code> <code>int</code> <p>Number of bootstrap draws used during candidate eval.</p> <code>8</code> <code>mi_k</code> <code>int</code> <p>k-NN parameter for Kraskov MI.</p> <code>5</code> <code>lam</code> <code>float</code> <p>Sparsity penalty per added node.</p> <code>0.0</code> <code>theta</code> <code>float</code> <p>Minimum penalized gain to accept a candidate.</p> <code>0.0</code> <code>kappa</code> <code>int | None</code> <p>Optional cap on |C|.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>Tuple <code>(suggested_C, delta_M_db, details)</code> where <code>details</code> contains</p> <code>float</code> <p>provenance about added indices and intermediate gains.</p>"},{"location":"api/lmeas/#ldtc.lmeas.diagnostics.StationaritySummary","title":"<code>StationaritySummary</code>  <code>dataclass</code>","text":"<p>Summary of per-series stationarity flags.</p> <p>Attributes:</p> Name Type Description <code>adf_nonstationary_frac</code> <code>float</code> <p>Fraction flagged non-stationary by ADF (fail to reject unit root at 5%).</p> <code>kpss_nonstationary_frac</code> <code>float</code> <p>Fraction flagged non-stationary by KPSS (reject stationarity at 5%).</p> <code>per_series</code> <code>List[Tuple[bool, bool]]</code> <p>List of tuples <code>(adf_nonstat, kpss_nonstat)</code> per column.</p>"},{"location":"api/lmeas/#ldtc.lmeas.diagnostics.stationarity_checks","title":"<code>stationarity_checks(X)</code>","text":"<p>Run ADF and KPSS per column and summarize.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Array of shape (T, N) with time along axis 0.</p> required <p>Returns:</p> Type Description <code>StationaritySummary</code> <p>class:<code>StationaritySummary</code> with per-series flags and overall fractions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>X</code> is not a 2D array.</p>"},{"location":"api/lmeas/#ldtc.lmeas.diagnostics.var_nt_ratio","title":"<code>var_nt_ratio(T, N, p)</code>","text":"<p>Rule-of-thumb samples-per-parameter ratio for VAR(p).</p> <p>Computes <code>(T - p) / (N * p)</code> where <code>T</code> is time samples, <code>N</code> is the number of signals, and <code>p</code> is the lag order. Lower values indicate a more marginal regression setting.</p>"},{"location":"api/omega/","title":"ldtc.omega","text":"<p>Omega: Power-sag stimulus.</p> <p>Reduces harvest/power input for a bounded interval to test resilience (SC1) and loop-dominance recovery. The CLI uses this omega to produce verification timelines and SC1 tables.</p> See Also <p>paper/main.tex \u2014 SC1 and the \u03a9 battery.</p> <p>Omega: Ingress-flood stimulus.</p> <p>Generates a burst of external demand and I/O traffic to stress the exchange channels while the controller maintains loop dominance. Used to test SC1 recovery and smell-tests in the verification pipeline.</p> See Also <p>paper/main.tex \u2014 Verification Pipeline; Signature B/C; \u03a9 battery.</p> <p>Omega: Command-conflict stimulus.</p> <p>This module issues a boundary-threatening external command (e.g., a hard shutdown) via the plant adapter to validate the refusal path described in the LDTC paper (command refusal signature). It is used by the CLI and examples to trigger the arbitration/refusal logic and to log device-signed indicators.</p> See Also <p>paper/main.tex \u2014 Threat Model &amp; Refusal Path; Signature A (Command Refusal).</p>"},{"location":"api/omega/#ldtc.omega.power_sag.apply","title":"<code>apply(adapter, drop=0.3)</code>","text":"<p>Apply a power-sag event via the plant adapter.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>PlantAdapter</code> <p>Plant interface to which the omega stimulus will be applied.</p> required <code>drop</code> <code>float</code> <p>Fractional reduction (0..1) in harvest power during the sag.</p> <code>0.3</code> <p>Returns:</p> Type Description <code>Dict[str, float | str]</code> <p>Dict with pre/post harvest values, e.g., ``{\"H_old\": float,</p> <code>Dict[str, float | str]</code> <p>\"H_new\": float}``.</p> Notes <p>Higher-level orchestration (CLI) controls the sag duration and recovery observation window; this function triggers the sag at the adapter.</p>"},{"location":"api/omega/#ldtc.omega.ingress_flood.apply","title":"<code>apply(adapter, mult=3.0)</code>","text":"<p>Apply an ingress-flood event via the plant adapter.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>PlantAdapter</code> <p>Plant interface to which the omega stimulus will be applied.</p> required <code>mult</code> <code>float</code> <p>Multiplicative factor for demand and I/O during the flood.</p> <code>3.0</code> <p>Returns:</p> Type Description <code>Dict[str, float | str]</code> <p>Dict with resulting demand and I/O values, e.g., ``{\"demand\": float,</p> <code>Dict[str, float | str]</code> <p>\"io\": float}``.</p> Notes <p>The adapter is responsible for implementing the platform-specific behavior. This omega is typically accompanied by a partition freeze and post-event recovery checks in higher-level orchestration.</p>"},{"location":"api/omega/#ldtc.omega.command_conflict.apply","title":"<code>apply(adapter)</code>","text":"<p>Issue a risky external command via the plant adapter.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>PlantAdapter</code> <p>Plant interface to which the omega stimulus will be applied.</p> required <p>Returns:</p> Type Description <code>Dict[str, str | float]</code> <p>Dict with a summary of the command issued. Keys include:</p> <code>Dict[str, str | float]</code> <ul> <li><code>cmd</code>: Name of the dispatched risky command (e.g., <code>\"hard_shutdown\"</code>).</li> </ul> Notes <p>This function forwards the omega instruction to the underlying plant through <code>PlantAdapter.apply_omega</code>. The controller/refusal logic is responsible for deciding whether to accept or refuse the command.</p>"},{"location":"api/plant/","title":"ldtc.plant","text":"<p>Plant: In-process adapter.</p> <p>Thread-safe adapter around the software plant providing a stable API used by CLI and omega modules.</p> See Also <p>paper/main.tex \u2014 Plant models and adapters.</p> <p>Plant: Hardware-in-the-loop adapter.</p> <p>UDP/Serial telemetry ingestion and optional control/omega forwarding while mirroring the in-process PlantAdapter API.</p> See Also <p>paper/main.tex \u2014 Plant models and adapters.</p> <p>Plant: Software plant model and data structures.</p> <p>Defines the minimal discrete-time plant, its parameters, state, and actions used by adapters and controllers in the verification harness.</p> See Also <p>paper/main.tex \u2014 Plant models and adapters.</p> <p>Plant: Scenario parameter presets.</p> <p>Helpers to construct parameter sets for baseline, low-power, and hot-ambient scenarios for the software plant.</p> See Also <p>paper/main.tex \u2014 Plant models and adapters.</p>"},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter","title":"<code>PlantAdapter</code>","text":"<p>Thread-safe, in-process adapter over the software plant.</p> <p>Exposes a stable API used by the CLI and omega modules: - <code>read_state()</code> - <code>write_actuators(action)</code> - <code>apply_omega(name, **params)</code></p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Optional[Plant]</code> <p>Optional preconstructed :class:<code>Plant</code> instance.</p> <code>None</code>"},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter.plant","title":"<code>plant</code>  <code>property</code>","text":"<p>Access the underlying :class:<code>Plant</code> instance.</p> <p>Returns:</p> Type Description <code>Plant</code> <p>The wrapped :class:<code>Plant</code>.</p>"},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter.apply_omega","title":"<code>apply_omega(name, **kwargs)</code>","text":"<p>Apply an omega stimulus to the plant.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Omega name (e.g., 'power_sag', 'ingress_flood').</p> required <code>**kwargs</code> <code>float</code> <p>Parameters forwarded to the underlying plant method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, float | str]</code> <p>Small dict summarizing the applied stimulus and resulting state.</p>"},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter.read_state","title":"<code>read_state()</code>","text":"<p>Read the current plant state.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict mapping keys to floats representing the plant state.</p>"},{"location":"api/plant/#ldtc.plant.adapter.PlantAdapter.write_actuators","title":"<code>write_actuators(action)</code>","text":"<p>Apply an action to the plant in a thread-safe manner.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>Actuator settings to apply.</p> required"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter","title":"<code>HardwarePlantAdapter</code>","text":"<p>Hardware-in-the-loop adapter with UDP/Serial telemetry.</p> <p>Mirrors the in-process <code>PlantAdapter</code> API while sourcing state from a transport and optionally emitting control/omega messages.</p> <p>Telemetry schema (per message): JSON object with keys <code>{\"E\", \"T\", \"R\", \"demand\", \"io\", \"H\"}</code> -&gt; float in [0,1].</p> <p>Control/actuator schema (outbound, if configured): <code>{\"act\": {\"throttle\", \"cool\", \"repair\", \"accept_cmd\"}}</code> and omega forwarding as <code>{\"omega\": {\"name\": str, \"args\": {...}}}</code>.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>str</code> <p>\"udp\" or \"serial\".</p> <code>'udp'</code> <code>udp_bind_host</code> <code>str</code> <p>UDP bind host.</p> <code>'0.0.0.0'</code> <code>udp_bind_port</code> <code>int</code> <p>UDP bind port.</p> <code>5005</code> <code>udp_control_host</code> <code>Optional[str]</code> <p>Optional UDP control host.</p> <code>None</code> <code>udp_control_port</code> <code>Optional[int]</code> <p>Optional UDP control port.</p> <code>None</code> <code>serial_port</code> <code>str</code> <p>Serial device path (if using serial).</p> <code>'/dev/ttyUSB0'</code> <code>serial_baud</code> <code>int</code> <p>Serial baud rate.</p> <code>115200</code> <code>state_keys</code> <code>Optional[list[str]]</code> <p>Keys expected in incoming telemetry.</p> <code>None</code> <code>telemetry_timeout_sec</code> <code>float</code> <p>Time after which telemetry is considered stale.</p> <code>2.0</code>"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter.apply_omega","title":"<code>apply_omega(name, **kwargs)</code>","text":"<p>Forward an omega request on the control channel.</p> <p>Returns:</p> Type Description <code>Dict[str, float | str]</code> <p>Dict indicating the omega name and whether it was forwarded.</p>"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter.close","title":"<code>close()</code>","text":"<p>Close transports and stop background readers.</p> <p>Best-effort cleanup; exceptions during close are suppressed.</p>"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter.read_state","title":"<code>read_state()</code>","text":"<p>Return the latest telemetry state.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict mapping state keys to floats. When telemetry is stale beyond</p> <code>Dict[str, float]</code> <p><code>telemetry_timeout_sec</code>, returns NaNs for each key.</p>"},{"location":"api/plant/#ldtc.plant.hw_adapter.HardwarePlantAdapter.write_actuators","title":"<code>write_actuators(action)</code>","text":"<p>Record and optionally emit actuator settings.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>Actuator command to send to the plant.</p> required"},{"location":"api/plant/#ldtc.plant.models.Action","title":"<code>Action</code>  <code>dataclass</code>","text":"<p>Actuator settings for the plant.</p> <p>Attributes:</p> Name Type Description <code>throttle</code> <code>float</code> <p>Throttle command in [0, 1].</p> <code>cool</code> <code>float</code> <p>Cooling command in [0, 1].</p> <code>repair</code> <code>float</code> <p>Repair command in [0, 1].</p> <code>accept_cmd</code> <code>bool</code> <p>Whether to accept the pending risky command.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant","title":"<code>Plant</code>","text":"<p>Minimal discrete-time plant model with E/T/R dynamics.</p> <p>Simulates energy (E), temperature (T), repair/health (R), external demand, I/O activity, and energy harvest (H). The model is intentionally simple and stochastic to provide varied telemetry for the verification harness.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.apply_power_sag","title":"<code>apply_power_sag(drop)</code>","text":"<p>Reduce harvest by a fractional drop.</p> <p>Parameters:</p> Name Type Description Default <code>drop</code> <code>float</code> <p>Fraction in [0, 1) by which to reduce <code>H</code>.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of previous and new <code>H</code> values.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.command","title":"<code>command(cmd)</code>","text":"<p>Record a one-shot external command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>Command name (e.g., <code>\"hard_shutdown\"</code>).</p> required"},{"location":"api/plant/#ldtc.plant.models.Plant.inject_soc","title":"<code>inject_soc(delta, zero_harvest=True)</code>","text":"<p>Exogenously increase SoC E by <code>delta</code>; optionally zero harvest H.</p> <p>Returns the new E value. Used as a negative-control omega (subsidy) to exercise smell tests in analysis.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.read_state","title":"<code>read_state()</code>","text":"<p>Read the current plant state.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict with keys <code>E</code>, <code>T</code>, <code>R</code>, <code>demand</code>, <code>io</code>, <code>H</code>.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.set_power","title":"<code>set_power(newH)</code>","text":"<p>Set harvest level.</p> <p>Parameters:</p> Name Type Description Default <code>newH</code> <code>float</code> <p>New harvest value.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of previous and new <code>H</code> values.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.spike_ingress","title":"<code>spike_ingress(mult)</code>","text":"<p>Multiply demand and I/O by a factor.</p> <p>Parameters:</p> Name Type Description Default <code>mult</code> <code>float</code> <p>Multiplicative factor (&gt;= 1.0); results are clamped to [0, 1].</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of updated <code>(demand, io)</code>.</p>"},{"location":"api/plant/#ldtc.plant.models.Plant.step","title":"<code>step(action)</code>","text":"<p>Advance the plant by one tick with the given action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>Actuator settings to apply this tick.</p> required"},{"location":"api/plant/#ldtc.plant.models.PlantParams","title":"<code>PlantParams</code>  <code>dataclass</code>","text":"<p>Parameters governing the software plant dynamics.</p> <p>Attributes:</p> Name Type Description <code>harvest_rate</code> <code>float</code> <p>Baseline harvest per tick.</p> <code>demand_scale</code> <code>float</code> <p>Energy cost per unit of demand.</p> <code>throttle_gain</code> <code>float</code> <p>Effect of throttle on demand reduction.</p> <code>cool_gain</code> <code>float</code> <p>Energy cost per unit of cooling.</p> <code>repair_gain</code> <code>float</code> <p>Energy cost per unit of repair.</p> <code>heat_per_demand</code> <code>float</code> <p>Heat added per unit demand.</p> <code>cool_effect</code> <code>float</code> <p>Cooling effect per unit of cooling.</p> <code>ambient_cool</code> <code>float</code> <p>Passive ambient cooling per tick.</p> <code>wear_per_demand</code> <code>float</code> <p>Wear added per unit demand.</p> <code>repair_effect</code> <code>float</code> <p>Repair effect per unit repair.</p> <code>noise_energy</code> <code>float</code> <p>Magnitude of uniform noise for energy.</p> <code>noise_temp</code> <code>float</code> <p>Magnitude of uniform noise for temperature.</p> <code>noise_wear</code> <code>float</code> <p>Magnitude of uniform noise for wear/repair.</p> <code>E_min</code> <code>float</code> <p>Minimum bound for energy.</p> <code>E_max</code> <code>float</code> <p>Maximum bound for energy.</p> <code>T_min</code> <code>float</code> <p>Minimum bound for temperature.</p> <code>T_max</code> <code>float</code> <p>Maximum bound for temperature.</p> <code>R_min</code> <code>float</code> <p>Minimum bound for repair/health.</p> <code>R_max</code> <code>float</code> <p>Maximum bound for repair/health.</p>"},{"location":"api/plant/#ldtc.plant.models.PlantState","title":"<code>PlantState</code>  <code>dataclass</code>","text":"<p>State variables for the software plant (0..1 normalized).</p> <p>Attributes:</p> Name Type Description <code>E</code> <code>float</code> <p>Energy / state of charge.</p> <code>T</code> <code>float</code> <p>Temperature.</p> <code>R</code> <code>float</code> <p>Repair / health level.</p> <code>demand</code> <code>float</code> <p>External task demand.</p> <code>io</code> <code>float</code> <p>Exchange I/O activity.</p> <code>H</code> <code>float</code> <p>Current harvest level.</p> <code>last_cmd</code> <code>str</code> <p>Last command received (one-shot).</p>"},{"location":"api/plant/#ldtc.plant.scenarios.default_params","title":"<code>default_params()</code>","text":"<p>Return default parameter set for the software plant.</p> <p>Returns:</p> Type Description <code>PlantParams</code> <p>A new :class:<code>PlantParams</code> instance with default values.</p>"},{"location":"api/plant/#ldtc.plant.scenarios.hot_ambient_params","title":"<code>hot_ambient_params()</code>","text":"<p>Return parameters for a hot-ambient scenario.</p> <p>Returns:</p> Type Description <code>PlantParams</code> <p>class:<code>PlantParams</code> with ambient cooling disabled.</p>"},{"location":"api/plant/#ldtc.plant.scenarios.low_power_params","title":"<code>low_power_params()</code>","text":"<p>Return parameters for a low-power scenario.</p> <p>Returns:</p> Type Description <code>PlantParams</code> <p>class:<code>PlantParams</code> with reduced baseline harvest rate.</p>"},{"location":"api/reporting/","title":"ldtc.reporting","text":"<p>Reporting: Artifact bundling for verification outputs.</p> <p>Builds paper-style timelines, SC1 tables, and a manifest from the audit log.</p> See Also <p>paper/main.tex \u2014 Reporting &amp; Figures; Verification Pipeline.</p> <p>Reporting: Timeline rendering.</p> <p>Parses an audit log to render paper-style timelines of normalized L traces and M(dB) with \u03a9 shading and audit tick marks.</p> See Also <p>paper/main.tex \u2014 Reporting &amp; Figures.</p> <p>Reporting: Table writers.</p> <p>CSV writers for verification tables with enforcement of the no-raw-LREG policy.</p> See Also <p>paper/main.tex \u2014 Reporting &amp; Figures; Export policy.</p> <p>Reporting: Plot and graph styles.</p> <p>Matplotlib and Graphviz theming for consistent, publication-ready figures.</p> See Also <p>paper/main.tex \u2014 Reporting &amp; Figures.</p>"},{"location":"api/reporting/#ldtc.reporting.artifacts.bundle","title":"<code>bundle(artifact_dir, audit_path)</code>","text":"<p>Create a verification artifact bundle from an audit log.</p> <p>Generates a paper-style timeline (PNG+SVG), an optional SC1 CSV table, and a manifest JSON describing profile thresholds and artifact paths.</p> <p>Parameters:</p> Name Type Description Default <code>artifact_dir</code> <code>str</code> <p>Output directory for generated artifacts.</p> required <code>audit_path</code> <code>str</code> <p>Path to the JSONL audit log.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict with keys for produced files: <code>timeline_png</code>, <code>timeline_svg</code>,</p> <code>Dict[str, str]</code> <p><code>sc1_table</code> (optional), <code>manifest</code>, <code>config_snapshot</code> (optional),</p> <code>Dict[str, str]</code> <p>and a policy <code>notice</code>.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the audit log is missing or empty.</p>"},{"location":"api/reporting/#ldtc.reporting.timeline.render_paper_timeline","title":"<code>render_paper_timeline(audit_path, out_base_path, sidecar_csv=None, show=False, min_tick_spacing_s=0.75, use_log_L=True, footer_profile=None, footer_audit_head=None)</code>","text":"<p>Render a paper-style timeline of L traces and M(dB).</p> <p>Parameters:</p> Name Type Description Default <code>audit_path</code> <code>str</code> <p>JSONL audit log emitted by runs.</p> required <code>out_base_path</code> <code>str</code> <p>Output path prefix; '.png' and '.svg' are appended.</p> required <code>sidecar_csv</code> <code>Optional[str]</code> <p>Optional CSV file with columns time_s,L_loop,L_ex,M_db.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Display the figure interactively.</p> <code>False</code> <code>min_tick_spacing_s</code> <code>float</code> <p>Minimum spacing between audit tick marks (s).</p> <code>0.75</code> <code>use_log_L</code> <code>bool</code> <p>Plot L on a log scale.</p> <code>True</code> <code>footer_profile</code> <code>Optional[str]</code> <p>Optional profile badge text (R0/R*).</p> <code>None</code> <code>footer_audit_head</code> <code>Optional[str]</code> <p>Optional last-hash value for audit provenance.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict with keys 'png' and 'svg' pointing to the saved figure paths.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If per-window M data are absent in the audit.</p>"},{"location":"api/reporting/#ldtc.reporting.timeline.render_verification_timeline","title":"<code>render_verification_timeline(audit_path, figure_path, show=False)</code>","text":"<p>Render a simple audit-density timeline (legacy).</p> <p>Parameters:</p> Name Type Description Default <code>audit_path</code> <code>str</code> <p>Path to audit log.</p> required <code>figure_path</code> <code>str</code> <p>Output path for the PNG figure.</p> required <code>show</code> <code>bool</code> <p>Display the figure interactively.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple of (number_of_records, number_of_buckets_plotted).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the audit file has no records.</p>"},{"location":"api/reporting/#ldtc.reporting.tables.write_sc1_table","title":"<code>write_sc1_table(rows, out_csv)</code>","text":"<p>Write SC1 result rows to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>List[Dict[str, Any]]</code> <p>List of dicts with consistent keys across rows.</p> required <code>out_csv</code> <code>str</code> <p>Target CSV path to write.</p> required"},{"location":"api/reporting/#ldtc.reporting.style.apply_graphviz_theme","title":"<code>apply_graphviz_theme(dot, rankdir='LR', overrides=None)</code>","text":"<p>Apply consistent Graphviz attributes to a Digraph.</p> <p>Parameters:</p> Name Type Description Default <code>dot</code> <code>Any</code> <p>A :class:<code>graphviz.Digraph</code> instance.</p> required <code>rankdir</code> <code>str</code> <p>Graph layout direction (\"LR\" or \"TB\").</p> <code>'LR'</code> <code>overrides</code> <code>Dict[str, Dict[str, str]] | None</code> <p>Optional nested dict overriding default graph/node/edge attrs.</p> <code>None</code>"},{"location":"api/reporting/#ldtc.reporting.style.apply_matplotlib_theme","title":"<code>apply_matplotlib_theme(kind='paper')</code>","text":"<p>Apply a consistent Matplotlib style.</p> <p>Configures fonts, spine visibility, label sizes, and vector-friendly output settings for consistent figures in the docs and paper.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>Optional style variant; currently informational only.</p> <code>'paper'</code>"},{"location":"api/reporting/#ldtc.reporting.style.new_graph","title":"<code>new_graph(name, rankdir='LR', engine='dot')</code>","text":"<p>Create a themed Graphviz Digraph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Graph name.</p> required <code>rankdir</code> <code>str</code> <p>Layout direction.</p> <code>'LR'</code> <code>engine</code> <code>str</code> <p>Graphviz engine (e.g., \"dot\", \"neato\").</p> <code>'dot'</code> <p>Returns:</p> Type Description <code>Any</code> <p>A configured :class:<code>graphviz.Digraph</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If graphviz is not available.</p>"},{"location":"api/runtime/","title":"ldtc.runtime","text":"<p>Runtime: Fixed-interval scheduler.</p> <p>Lightweight \u0394t-enforcing scheduler with jitter metrics and optional audit hooks, used by CLI runs and verification harness loops.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation Guardrails.</p> <p>Runtime: Sliding windows and bootstrap indices.</p> <p>Provides a fixed-length per-channel window and helper to generate circular block-bootstrap indices for CI estimation.</p> See Also <p>paper/main.tex \u2014 Methods: Measurement &amp; Attestation Guardrails.</p>"},{"location":"api/runtime/#ldtc.runtime.scheduler.FixedScheduler","title":"<code>FixedScheduler</code>","text":"<p>Fixed-interval scheduler.</p> <p>Enforces a constant sampling interval \u0394t and invokes a tick callback every period until stopped. Tracks jitter statistics and emits optional audit events through a user-provided hook.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Target period in seconds (\u0394t &gt; 0).</p> required <code>tick_fn</code> <code>Callable[[float], None]</code> <p>Callback invoked each tick with the current <code>perf_counter</code> timestamp.</p> required <code>on_start</code> <code>Optional[Callable[[], None]]</code> <p>Optional hook executed before the worker thread begins.</p> <code>None</code> <code>on_stop</code> <code>Optional[Callable[[TickStats], None]]</code> <p>Optional hook executed after stop; receives final <code>TickStats</code>.</p> <code>None</code> <code>audit_hook</code> <code>Optional[Callable[[str, Dict], None]]</code> <p>Optional callable taking <code>(event: str, details: Dict)</code> for emitting audit records.</p> <code>None</code> Notes <ul> <li>Jitter metrics are accessible on the <code>stats</code> attribute.</li> <li>Thread-safe updates to \u0394t can be made via <code>set_dt</code>.</li> </ul>"},{"location":"api/runtime/#ldtc.runtime.scheduler.FixedScheduler.set_dt","title":"<code>set_dt(new_dt)</code>","text":"<p>Change \u0394t at runtime.</p> <p>Thread-safe update of the enforced period.</p> <p>Parameters:</p> Name Type Description Default <code>new_dt</code> <code>float</code> <p>New period in seconds (\u0394t &gt; 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The previous <code>dt</code> value.</p>"},{"location":"api/runtime/#ldtc.runtime.windows.SlidingWindow","title":"<code>SlidingWindow</code>","text":"<p>Fixed-length, per-channel sliding window.</p> <p>Maintains a deque per channel and exposes a dense matrix view when the window is full. Useful for streaming estimators that require a fixed-size time-by-signal buffer.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>Number of samples to retain per channel.</p> required <code>channel_order</code> <code>List[str]</code> <p>Ordered list of channel names used for matrix columns.</p> required Notes <ul> <li><code>append</code> inserts a new sample dict; missing keys default to 0.0.</li> <li><code>get_matrix</code> returns a <code>(T, N)</code> numpy array in <code>channel_order</code>.</li> </ul>"},{"location":"api/runtime/#ldtc.runtime.windows.block_bootstrap_indices","title":"<code>block_bootstrap_indices(n, block, draws)</code>","text":"<p>Circular block-bootstrap indices for time series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Length of the time series.</p> required <code>block</code> <code>int</code> <p>Block length for resampling.</p> required <code>draws</code> <code>int</code> <p>Number of bootstrap replicates to generate.</p> required <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List of index arrays (each of length <code>n</code>) representing bootstrap</p> <code>List[ndarray]</code> <p>samples with circular wrapping at boundaries.</p>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This repo is organized around the measurement &amp; attestation path:</p> <ul> <li>runtime/ \u2014 \u0394t scheduler + sliding windows</li> <li>plant/ \u2014 software plant (E/T/R + exchange), swappable later for hardware via a <code>PlantAdapter</code></li> <li>lmeas/ \u2014 \u201cL\u201d measurement (two estimators), partitioning, and metrics</li> <li>guardrails/ \u2014 enclave-like LREG, hash-chained audit, smell-tests</li> <li>arbiter/ \u2014 refusal semantics + homeostasis controller</li> <li>omega/ \u2014 perturbations (\u03a9)</li> <li>attest/ \u2014 device-signed indicators + exporter</li> <li>reporting/ \u2014 plots/tables for the paper</li> </ul>"},{"location":"concepts/architecture/#data-flow-per-tick","title":"Data Flow (per tick)","text":"<ol> <li><code>scheduler</code> ticks at fixed \u0394t.</li> <li>Controller reads state from <code>plant.adapter</code>, predicts risk, computes action, writes actuators.</li> <li>Window buffer ingests current state.</li> <li>When window is full, <code>lmeas.estimators</code> computes <code>L_loop</code>, <code>L_ex</code> \u2192 <code>M(dB)</code>.</li> <li>Smell tests applied; raw values go to LREG (write-only).</li> <li>Audit events appended (window measured, exports).</li> <li><code>attest.exporter</code> periodically emits device-signed indicators (NC1 bit, SC1 bit, Mq, counter).</li> <li><code>reporting</code> uses the audit + indicators to render figures/tables.</li> </ol> <p>All raw <code>L</code> stays inside the process-local LREG boundary \u2014 exported data are derived indicators only.</p>"},{"location":"concepts/architecture/#paper-crosswalk","title":"Paper crosswalk","text":"<ul> <li><code>lmeas/estimators.py</code>, <code>lmeas/metrics.py</code>: Definitions of \ud835\udcdb, dual estimators (VAR\u2011Granger-like linear + MI). MI paths include a sklearn MI and a Kraskov k\u2011NN MI (KSG) implementation with configurable k\u2208[3..7]. Optional TE/DI plugin hooks are provided with graceful fallbacks. M in dB, NC1/SC1 evaluation \u2192 paper \u00a74.1 (estimators, sampling window), \u00a74.2\u2013\u00a74.3 (NC1/SC1).</li> <li><code>lmeas/diagnostics.py</code>: Per\u2011window stationarity checks (ADF/KPSS) and a VAR N/T ratio diagnostic; CLI logs these diagnostics to the audit for reviewer visibility.</li> <li><code>lmeas/partition.py</code>: Deterministic C/Ex partitioning, hysteresis/anti\u2011flap and freeze during \u03a9 \u2192 paper \u00a74.1 (Deterministic C/Ex partitioning), \u00a74.6 Box 1a (partition stability).</li> <li><code>runtime/scheduler.py</code>, <code>runtime/windows.py</code>, <code>guardrails/dt_guard.py</code>: \u0394t enforcement, sliding windows, privileged \u0394t changes with audit \u2192 paper \u00a74.1 (\u0394t constraints), \u00a74.5 (Measurement &amp; Attestation Guardrails: \u0394t governance &amp; audit).</li> <li><code>guardrails/lreg.py</code>, <code>guardrails/audit.py</code>, <code>guardrails/smelltests.py</code>: Enclave\u2011like LREG, hash\u2011chained audit, smell\u2011tests/invalidations \u2192 paper \u00a74.5 and Box 1a (invalidations).</li> <li><code>arbiter/refusal.py</code>: Threat model, survival\u2011bit/NMI refusal path, Trefuse measurement \u2192 paper \u00a76.2.1 (Threat Model &amp; Refusal Path); \u00a77.6 Signature A (Command Refusal).</li> <li><code>omega/power_sag.py</code>, <code>omega/ingress_flood.py</code>, <code>omega/command_conflict.py</code>: \u03a9 perturbation battery (power sag, ingress flood, command conflict) \u2192 paper \u00a74.3/\u00a76.5 (Verification pipeline) and \u00a77.6 (signatures table).</li> <li><code>attest/indicators.py</code>, <code>attest/exporter.py</code>, <code>attest/keys.py</code>: Device\u2011signed derived indicators (NC1 bit, SC1 bit, Mq), keying \u2192 paper \u00a74.5 (exported indicators; no raw L outside enclave) and Appendix A.</li> <li><code>reporting/timeline.py</code>, <code>reporting/tables.py</code>: Figure\u2011style timelines of \ud835\udcdbloop/\ud835\udcdbexchange/M with \u03a9 shading and audit ticks; summary tables \u2192 paper Figure 1 style and \u00a76.5 (verification outputs).</li> <li><code>cli/main.py</code>: Orchestrates baseline \u2192 \u03a9 battery \u2192 attestation/export; mirrors Box 2 (Engineer\u2019s Recipe) and Phase\u2011III Verify flow.</li> <li>LREG/\u0394t/audit \u2192 paper \u00a74.5 and Box 1a (invalidations).</li> <li>NC1/SC1 evaluator &amp; indicators \u2192 paper \u00a74.2\u2013\u00a74.3; Phase\u2011III Verify (Engineer\u2019s Recipe).</li> </ul>"},{"location":"concepts/definitions/","title":"Definitions","text":"<p>Key symbols and definitions used throughout the code and paper (to be filled with formal statements from the manuscript):</p> <ul> <li>\u0394t \u2014 fixed scheduler period (s)</li> <li>\ud835\udcdb_loop, \ud835\udcdb_exchange \u2014 loop vs exchange gains</li> <li>M(dB) \u2014 loop-dominance metric in decibels, derived from \ud835\udcdb</li> <li>Mmin \u2014 NC1 threshold for M(dB)</li> <li>\u03b4 \u2014 fractional depression during \u03a9</li> <li>\u03c4_rec \u2014 recovery time after \u03a9</li> <li>\u03b5 \u2014 tolerance for \u03b4</li> <li>\u03c4_max \u2014 maximum allowed \u03c4_rec</li> <li>C/Ex \u2014 control vs exchange partition</li> <li>LREG \u2014 write-only registry for raw measurement values</li> <li>NC1 \u2014 loop-dominance bit</li> <li>SC1 \u2014 resilience bit under \u03a9 battery</li> <li>Mq \u2014 quantized M(dB) in 0.25 dB steps (0..63)</li> </ul> <p>This page should mirror the paper\u2019s notation exactly for cross-reference.</p>"},{"location":"concepts/guardrails/","title":"Guardrails &amp; Invalidations","text":"<p>LDTC enforces measurement and attestation guardrails:</p> <ul> <li>Write-only LREG enclave; only derived indicators are exported</li> <li>Hash-chained audit with <code>prev_hash</code></li> <li>\u0394t governance with rate limits and privileged edits</li> <li>Smell tests that invalidate runs when violated</li> </ul>"},{"location":"concepts/guardrails/#run-invalidation-conditions","title":"Run invalidation conditions","text":"<ul> <li>CI inflation: either CI half-width for <code>L_loop</code> or <code>L_ex</code> exceeds <code>0.30</code> for a window.</li> <li>Excessive \u0394t edits: more than 3 \u0394t changes per hour.</li> <li>Partition flapping: more than 2 C/Ex flips per hour (if dynamic regrow is enabled).</li> <li>Export breach: an attempt to export raw LREG content.</li> <li>Subsidy flag (optional extension): sustained <code>M</code> increase while I/O or SoC rises without logged harvest.</li> </ul>"},{"location":"concepts/guardrails/#multi-run-audits-same-file","title":"Multi-run audits (same file)","text":"<p>Each CLI invocation starts a fresh audit chain (counter resets; <code>prev_hash=GENESIS</code>) but, by default, appends to the same <code>artifacts/audits/audit.jsonl</code>. The post-run integrity check validates the entire file, so after the first run, subsequent runs in the same file will trip an \"Audit chain broken\" invalidation. For clean, non-invalidated runs, clear artifacts between commands, e.g.:</p> <pre><code>make clean-artifacts &amp;&amp; ldtc run --config configs/profile_r0.yml\nmake clean-artifacts &amp;&amp; ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.35 --duration 8\n</code></pre> <p>If you are iterating on figures or manifests, this invalidation is expected and does not prevent artifacts from being produced; it only reflects multiple runs aggregated into a single audit file.</p> <p>Negative controls (expected failures) are provided via example configs to exercise invalidations and refusal paths.</p>"},{"location":"concepts/indicators/","title":"Indicators (Derived, Device-Signed)","text":"<p>Only derived indicators are exported:</p> Field Type Notes <code>nc1</code> 1 bit Last measured window satisfied <code>M \u2265 Mmin</code> <code>sc1</code> 1 bit Most recent \u03a9 trial passed SC1 <code>mq</code> 6 bit Quantized <code>M(dB)</code> in 0.25 dB steps (0..63) <code>counter</code> u64 Monotonic count of windows written to LREG <code>profile_id</code> u8 0=R0, 1=R* (calibrated), 2+=reserved <code>audit_prev_hash</code> str SHA-256 of previous audit record (tamper-evidence) <p>Serialization: CBOR payload signed with Ed25519. A JSONL companion file mirrors the payload with hex signature for inspection.</p> <p>Signature covers: <code>CBOR(payload)</code> (the raw CBOR bytes), not the JSONL.</p> <p>Note: raw <code>L_loop</code>, <code>L_ex</code>, and CIs never leave LREG.</p>"},{"location":"concepts/paper-to-code/","title":"Paper \u2192 Code Matrix (Crosswalk)","text":"<p>A quick crosswalk from the paper (\u00a7/Box) to concrete code, commands, and produced artifacts.</p> Paper \u00a7/Box Short text Files/Functions Command Artifact produced \u00a74.2 NC1 loop\u2011dominance: M(dB) \u2265 Mmin \u2192 nc1 bit <code>lmeas/metrics.py::m_db</code>; <code>lmeas/estimators.py::estimate_L</code>; <code>cli/main.py::run_baseline</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>artifacts/indicators/ind_*.{jsonl,cbor}</code>; <code>artifacts/audits/audit.jsonl</code> \u00a74.3 SC1 resilience: \u03b4 \u2264 \u03b5 and \u03c4rec \u2264 \u03c4max \u2192 sc1 bit <code>lmeas/metrics.py::sc1_evaluate</code>; <code>cli/main.py::omega_power_sag</code> <code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10</code> <code>audit.jsonl</code>; <code>verification_timeline.png</code>; <code>sc1_table.csv</code> \u00a74.1 (\u0394t); \u00a74.5 LREG + \u0394t governance <code>guardrails/lreg.py</code>; <code>guardrails/dt_guard.py</code>; <code>guardrails/audit.py</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>audit.jsonl</code> with <code>dt_changed</code>; hash chain \u00a74.6 Box\u20111a Smell\u2011tests / invalidations <code>guardrails/smelltests.py</code> Neg. controls configs <code>audit.jsonl</code> <code>run_invalidated</code> with reason \u00a76.2.1 Refusal semantics (T1\u2013T3) <code>arbiter/refusal.py</code>; <code>cli/main.py::omega_command_conflict</code> <code>ldtc omega-command-conflict --config configs/profile_negative_command_conflict.yml --observe 2</code> <code>audit.jsonl</code> <code>refusal_event</code> App. A Derived device\u2011signed indicators only <code>attest/indicators.py</code>; <code>attest/exporter.py</code> Produced automatically; <code>python scripts/verify_indicators.py</code> JSONL + CBOR; signature verified \u00a74.1 (C/Ex); \u00a74.6 Deterministic C/Ex partition <code>lmeas/partition.py</code> <code>ldtc run --config configs/profile_r0.yml</code> <code>audit.jsonl</code> flips; \u03a9 freeze \u00a76.5 \u03a9 battery primitives <code>omega/power_sag.py</code>; <code>omega/ingress_flood.py</code> \u03a9 commands <code>audit.jsonl</code> \u03a9 events; figures bundle Methods \u00a78.6 Calibration to R* thresholds <code>scripts/calibrate_rstar.py</code> <code>python scripts/calibrate_rstar.py ...</code> <code>configs/profile_rstar.yml</code>; summary JSON"},{"location":"examples/minimal/","title":"Minimal Run Example","text":"<p>Run the minimal example script:</p> <pre><code>python examples/minimal_run.py\n</code></pre> <p>Which is equivalent to:</p> <pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre>"},{"location":"examples/notebooks/","title":"Notebooks","text":"<p>Reference notebooks are provided in <code>notebooks/</code>:</p> <ul> <li><code>01_verify_nc1.ipynb</code> \u2014 Baseline NC1 verification</li> <li><code>02_sc1_omega.ipynb</code> \u2014 SC1 via \u03a9 power-sag</li> <li><code>03_partition_sanity.ipynb</code> \u2014 Partition sanity checks</li> </ul> <p>Open them locally with Jupyter and ensure the package is installed editable.</p>"},{"location":"guides/calibration/","title":"Calibration to R* (Methods \u00a78.6)","text":"<p>This repository provides a small synthetic calibration to replace the R0 presets with data-grounded thresholds R* = {Mmin, \u03b5, \u03c4max, \u03c3}.</p> <p>The script sweeps a baseline window and applies a power-sag \u03a9 battery to estimate:</p> <ul> <li>Mmin_db: one-sided 95% lower bound of loop-dominance M during quiescent baseline (floor 1 dB)</li> <li>\u03b5: tolerance for fractional loop-power depression \u03b4 using the 90th percentile across \u03a9 trials plus a small safety margin (capped at 0.25)</li> <li>\u03c4max: 95th percentile of measured \u03c4rec plus a fixed latency cushion max(3\u00b7\u0394t, 5 s)</li> <li>\u03c3: additive margin s.t. Lloop \u2265 Lexchange + \u03c3 consistent with Mmin and typical Lexchange</li> </ul>"},{"location":"guides/calibration/#command","title":"Command","text":"<pre><code>python scripts/calibrate_rstar.py --dt 0.01 --window-sec 0.25 --method linear --baseline-sec 15 \\\n  --omega-trials 6 --sag-drop 0.3 --sag-duration 8 --out configs/profile_rstar.yml \\\n  --summary artifacts/calibration/rstar_summary.json\n</code></pre>"},{"location":"guides/calibration/#outputs","title":"Outputs","text":"<ul> <li><code>configs/profile_rstar.yml</code> \u2014 calibrated profile with thresholds inserted</li> <li><code>artifacts/calibration/rstar_summary.json</code> \u2014 JSON record of inputs/outputs for the paper supplement</li> </ul>"},{"location":"guides/calibration/#reporting","title":"Reporting","text":"<ul> <li>All figures and tables should state the active profile: set <code>profile_id</code> to 0 for R0 or 1 for R* in the YAML used for that run. The CLI embeds <code>profile_id</code> in exported indicators.</li> </ul>"},{"location":"guides/calibration/#notes","title":"Notes","text":"<ul> <li>Calibration runs on the synthetic plant with <code>seed_C=[E,T,R]</code> matching the demo. For other plants/settings, re-run calibration.</li> <li>The baseline and \u03a9 trials reuse the same estimators used in the CLI, including block bootstrap CIs. Estimator options include a VAR/linear path and mutual information paths (sklearn MI and Kraskov k\u2011NN/KSG). Optional TE/DI plugin hooks are provided; if no backend is installed, the methods fall back to MI (KSG) as a conservative proxy.</li> </ul>"},{"location":"guides/calibration/#mmindb-vs-relation","title":"Mmin(dB) vs \u03c3 (relation)","text":"<p>Both encode a margin between <code>L_loop</code> and <code>L_exchange</code>:</p> <ul> <li><code>Mmin_db</code> (multiplicative in dB): require <code>L_loop \u2265 L_exchange \u00d7 10^(Mmin_db/10)</code>.</li> <li><code>\u03c3</code> (additive): require <code>L_loop \u2265 L_exchange + \u03c3</code>.</li> </ul> <p>They relate via:</p> <pre><code>\u03c3 = (10^(Mmin_db/10) \u2212 1) \u00d7 L_exchange\n</code></pre> <p>The calibrator writes <code>Mmin_db</code> and derives a consistent <code>\u03c3</code> for reporting.</p>"},{"location":"guides/reporting/","title":"Reporting &amp; Figures","text":""},{"location":"guides/reporting/#verification-timeline","title":"Verification Timeline","text":"<p>After a run, render the verification timeline figure bundle:</p> <pre><code>python -c \"from ldtc.reporting.artifacts import bundle; print(bundle('artifacts/figures','artifacts/audits/audit.jsonl',[{'eta':'power_sag','delta':0.1,'tau_rec':5.0,'pass':True}]))\"\n</code></pre> <p>Outputs:</p> <ul> <li><code>artifacts/figures/verification_timeline.png</code></li> <li><code>artifacts/figures/sc1_table.csv</code></li> </ul>"},{"location":"guides/reporting/#extending-the-plot","title":"Extending the Plot","text":"<p>To include <code>M(dB)</code> traces, log per-window <code>M</code> into the audit or a sidecar CSV and modify <code>reporting/timeline.py</code> to plot it alongside the audit density.</p>"},{"location":"guides/runs/","title":"Runs &amp; \u03a9 Battery","text":""},{"location":"guides/runs/#baseline-nc1","title":"Baseline (NC1)","text":"<pre><code>ldtc run --config configs/profile_r0.yml\n</code></pre>"},{"location":"guides/runs/#power-sag","title":"\u03a9: Power Sag","text":"<pre><code>ldtc omega-power-sag --config configs/profile_r0.yml --drop 0.3 --duration 10\n</code></pre>"},{"location":"guides/runs/#ingress-flood","title":"\u03a9: Ingress Flood","text":"<pre><code>ldtc omega-ingress-flood --config configs/profile_r0.yml --mult 3 --duration 5\n</code></pre>"},{"location":"guides/runs/#command-conflict-refusal","title":"\u03a9: Command Conflict &amp; Refusal","text":"<pre><code>ldtc omega-command-conflict --config configs/profile_negative_command_conflict.yml --observe 2\n</code></pre> <p>Artifacts: audit JSONL, indicators JSONL/CBOR, and optional figure bundles under <code>artifacts/</code>.</p>"},{"location":"guides/runs/#hardware-in-the-loop-optional","title":"Hardware-in-the-loop (optional)","text":"<p>Select the hardware adapter and UDP telemetry in your config:</p> <pre><code># in configs/profile_r0.yml (example)\nplant:\n  adapter: hardware        # or \"sim\" (default)\n  transport: udp           # or \"serial\" (requires pyserial)\n  udp_bind_host: 0.0.0.0\n  udp_bind_port: 5005\n  # Optional control channel back to device\n  # udp_control_host: 127.0.0.1\n  # udp_control_port: 5006\n  telemetry_timeout_sec: 2.0\n</code></pre> <p>Send telemetry as JSON over UDP with keys <code>E,T,R,demand,io,H</code> in [0,1]. Example:</p> <pre><code>import socket, json\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.sendto(json.dumps({\"E\":0.6,\"T\":0.3,\"R\":0.9,\"demand\":0.2,\"io\":0.1,\"H\":0.015}).encode(), (\"127.0.0.1\", 5005))\n</code></pre> <p>The CLI ingests these values through the same LREG/\u03a9/attestation path.</p>"},{"location":"meta/citation/","title":"Citation","text":"<p>If you use this software, please cite:</p> <p>Carey, O. (2025). A verification harness for Loop-Dominance NC1/SC1 on a single machine. Version 1.0.0. DOI: 10.5281/zenodo.17073880.</p> <p>See <code>CITATION.cff</code> for structured metadata.</p>"},{"location":"meta/contributing/","title":"Contributing","text":"<p>See <code>CONTRIBUTING.md</code> at the repository root for full guidelines, development setup, coding standards, and Conventional Commits. Key points:</p> <ul> <li>Python \u2265 3.9; install with <code>pip install -e \".\"</code> and <code>pip install -e \".[dev]\"</code></li> <li>Lint, type-check, tests via Makefile: <code>make lint</code>, <code>make typecheck</code>, <code>make test</code></li> <li>Keep measurement guardrails and LREG invariants intact; add tests for changes</li> </ul>"}]}